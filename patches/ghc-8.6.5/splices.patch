diff --git a/compiler/basicTypes/DataCon.hs b/compiler/basicTypes/DataCon.hs
index 3dd7e14b12..efcb26d047 100644
--- a/compiler/basicTypes/DataCon.hs
+++ b/compiler/basicTypes/DataCon.hs
@@ -811,6 +811,7 @@ instance Binary SrcUnpackedness where
            1 -> return SrcUnpack
            _ -> return NoSrcUnpack
 
+
 -- | Compare strictness annotations
 eqHsBang :: HsImplBang -> HsImplBang -> Bool
 eqHsBang HsLazy               HsLazy              = True
diff --git a/compiler/basicTypes/IdInfo.hs b/compiler/basicTypes/IdInfo.hs
index f6febaf4dc..aed09b6a42 100644
--- a/compiler/basicTypes/IdInfo.hs
+++ b/compiler/basicTypes/IdInfo.hs
@@ -18,7 +18,7 @@ module IdInfo (
         RecSelParent(..),
 
         -- * The IdInfo type
-        IdInfo,         -- Abstract
+        IdInfo,
         vanillaIdInfo, noCafIdInfo,
 
         -- ** The OneShotInfo type
diff --git a/compiler/basicTypes/IdInfo.hs-boot b/compiler/basicTypes/IdInfo.hs-boot
index cacfe6af2e..229ff9abb0 100644
--- a/compiler/basicTypes/IdInfo.hs-boot
+++ b/compiler/basicTypes/IdInfo.hs-boot
@@ -1,6 +1,7 @@
 module IdInfo where
 import GhcPrelude
 import Outputable
+
 data IdInfo
 data IdDetails
 
@@ -8,4 +9,3 @@ vanillaIdInfo :: IdInfo
 coVarDetails :: IdDetails
 isCoVarDetails :: IdDetails -> Bool
 pprIdDetails :: IdDetails -> SDoc
-
diff --git a/compiler/basicTypes/OccName.hs b/compiler/basicTypes/OccName.hs
index 1af53fb3dc..fa54967e8a 100644
--- a/compiler/basicTypes/OccName.hs
+++ b/compiler/basicTypes/OccName.hs
@@ -394,6 +394,10 @@ instance Uniquable OccName where
 newtype OccEnv a = A (UniqFM a)
   deriving Data
 
+instance Binary a => Binary (OccEnv a) where
+  put_ bh (A a) = put_ bh a
+  get bh = A <$> get bh
+
 emptyOccEnv :: OccEnv a
 unitOccEnv  :: OccName -> a -> OccEnv a
 extendOccEnv :: OccEnv a -> OccName -> a -> OccEnv a
diff --git a/compiler/basicTypes/PatSyn.hs b/compiler/basicTypes/PatSyn.hs
index 2e838d6b82..76b93e4224 100644
--- a/compiler/basicTypes/PatSyn.hs
+++ b/compiler/basicTypes/PatSyn.hs
@@ -32,6 +32,7 @@ import Outputable
 import Unique
 import Util
 import BasicTypes
+import Binary
 import Var
 import FieldLabel
 
@@ -328,6 +329,10 @@ instance Data.Data PatSyn where
     gunfold _ _  = error "gunfold"
     dataTypeOf _ = mkNoRepType "PatSyn"
 
+instance Binary PatSyn where
+  put = error "Binary PatSyn: not implemented yet"
+  get = error "Binary PatSyn: not implemented yet"
+
 {-
 ************************************************************************
 *                                                                      *
diff --git a/compiler/basicTypes/RdrName.hs b/compiler/basicTypes/RdrName.hs
index 610233ed9a..a4f1a68e65 100644
--- a/compiler/basicTypes/RdrName.hs
+++ b/compiler/basicTypes/RdrName.hs
@@ -75,6 +75,7 @@ import GhcPrelude
 import Module
 import Name
 import Avail
+import Binary
 import NameSet
 import Maybes
 import SrcLoc
@@ -466,6 +467,10 @@ data GlobalRdrElt
          -- INVARIANT: either gre_lcl = True or gre_imp is non-empty
          -- See Note [GlobalRdrElt provenance]
 
+instance Binary GlobalRdrElt where
+  put_ bh (GRE a b c d) = put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+  get bh = GRE <$> get bh <*> get bh <*> get bh <*> get bh
+
 -- | The children of a Name are the things that are abbreviated by the ".."
 --   notation in export lists.  See Note [Parents]
 data Parent = NoParent
@@ -474,6 +479,18 @@ data Parent = NoParent
               -- ^ See Note [Parents for record fields]
             deriving (Eq, Data)
 
+instance Binary Parent where
+  put_ bh p = case p of
+    NoParent      -> putByte bh 0
+    ParentIs p    -> putByte bh 1 >> put_ bh p
+    FldParent a b -> putByte bh 2 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure NoParent
+      1 -> ParentIs <$> get bh
+      _ -> FldParent <$> get bh <*> get bh
+
 instance Outputable Parent where
    ppr NoParent        = empty
    ppr (ParentIs n)    = text "parent:" <> ppr n
@@ -1134,6 +1151,10 @@ data ImportSpec = ImpSpec { is_decl :: ImpDeclSpec,
                             is_item :: ImpItemSpec }
                 deriving( Eq, Ord, Data )
 
+instance Binary ImportSpec where
+  put_ bh (ImpSpec a b) = put_ bh a >> put_ bh b
+  get bh = ImpSpec <$> get bh <*> get bh
+
 -- | Import Declaration Specification
 --
 -- Describes a particular import declaration and is
@@ -1151,6 +1172,11 @@ data ImpDeclSpec
         is_dloc     :: SrcSpan     -- ^ The location of the entire import declaration
     } deriving Data
 
+instance Binary ImpDeclSpec where
+  put_ bh (ImpDeclSpec a b c d) =
+    put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+  get bh = ImpDeclSpec <$> get bh <*> get bh <*> get bh <*> get bh
+
 -- | Import Item Specification
 --
 -- Describes import info a particular Name
@@ -1172,6 +1198,16 @@ data ImpItemSpec
         -- only @T@ is named explicitly.
   deriving Data
 
+instance Binary ImpItemSpec where
+  put_ bh s = case s of
+    ImpAll      -> putByte bh 0
+    ImpSome a b -> putByte bh 1 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure ImpAll
+      _ -> ImpSome <$> get bh <*> get bh
+
 instance Eq ImpDeclSpec where
   p1 == p2 = case p1 `compare` p2 of EQ -> True; _ -> False
 
diff --git a/compiler/ghc.cabal.in b/compiler/ghc.cabal.in
index 01628dcad1..3521bdc06c 100644
--- a/compiler/ghc.cabal.in
+++ b/compiler/ghc.cabal.in
@@ -210,6 +210,7 @@ Library
         NameSet
         OccName
         RdrName
+        SeName
         NameCache
         SrcLoc
         UniqSupply
@@ -318,6 +319,11 @@ Library
         HsDecls
         HsDoc
         HsExpr
+        HsExprBin
+        HsExprBin_ConversionPS2SE
+        HsExprBin_ConversionSE2PS
+        HsExprBin_Conversions
+        HsExprBin_Instances
         HsImpExp
         HsLit
         PlaceHolder
diff --git a/compiler/hsSyn/HsBinds.hs b/compiler/hsSyn/HsBinds.hs
index 98f503b0d9..9c3665f025 100644
--- a/compiler/hsSyn/HsBinds.hs
+++ b/compiler/hsSyn/HsBinds.hs
@@ -12,6 +12,7 @@ Datatype for: @BindGroup@, @Bind@, @Sig@, @Bind@.
 {-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE UndecidableInstances #-} -- Note [Pass sensitive types]
                                       -- in module PlaceHolder
+{-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE BangPatterns #-}
 {-# LANGUAGE TypeFamilies #-}
@@ -322,10 +323,12 @@ data NPatBindTc = NPatBindTc {
 type instance XFunBind    (GhcPass pL) GhcPs = NoExt
 type instance XFunBind    (GhcPass pL) GhcRn = NameSet -- Free variables
 type instance XFunBind    (GhcPass pL) GhcTc = NameSet -- Free variables
+type instance XFunBind    (GhcPass pL) GhcSe = NoExt
 
 type instance XPatBind    GhcPs (GhcPass pR) = NoExt
 type instance XPatBind    GhcRn (GhcPass pR) = NameSet -- Free variables
 type instance XPatBind    GhcTc (GhcPass pR) = NPatBindTc
+type instance XPatBind    GhcSe (GhcPass pR) = NoExt
 
 type instance XVarBind    (GhcPass pL) (GhcPass pR) = NoExt
 type instance XAbsBinds   (GhcPass pL) (GhcPass pR) = NoExt
@@ -382,6 +385,7 @@ data PatSynBind idL idR
 type instance XPSB         (GhcPass idL) GhcPs = NoExt
 type instance XPSB         (GhcPass idL) GhcRn = NameSet
 type instance XPSB         (GhcPass idL) GhcTc = NameSet
+type instance XPSB         (GhcPass idL) GhcSe = NoExt
 
 type instance XXPatSynBind (GhcPass idL) (GhcPass idR) = NoExt
 
@@ -828,6 +832,7 @@ type instance XIPBinds       GhcPs = NoExt
 type instance XIPBinds       GhcRn = NoExt
 type instance XIPBinds       GhcTc = TcEvBinds -- binds uses of the
                                                -- implicit parameters
+type instance XIPBinds       GhcSe = NoExt
 
 
 type instance XXHsIPBinds    (GhcPass p) = NoExt
@@ -948,7 +953,7 @@ data Sig pass
         -- the desired Id itself, replete with its name, type
         -- and IdDetails.  Otherwise it's just like a type
         -- signature: there should be an accompanying binding
-  | IdSig (XIdSig pass) Id
+  | IdSig (XIdSig pass) (IdSigId pass)
 
         -- | An ordinary fixity declaration
         --
@@ -1177,7 +1182,9 @@ ppr_sig (TypeSig _ vars ty)  = pprVarSig (map unLoc vars) (ppr ty)
 ppr_sig (ClassOpSig _ is_deflt vars ty)
   | is_deflt                 = text "default" <+> pprVarSig (map unLoc vars) (ppr ty)
   | otherwise                = pprVarSig (map unLoc vars) (ppr ty)
-ppr_sig (IdSig _ id)         = pprVarSig [id] (ppr (varType id))
+ppr_sig (IdSig _ id)         = case getVarType id of
+  Nothing -> ppr id
+  Just t  -> pprVarSig [id] (ppr t)
 ppr_sig (FixSig _ fix_sig)   = ppr fix_sig
 ppr_sig (SpecSig _ var ty inl@(InlinePragma { inl_inline = spec }))
   = pragSrcBrackets (inl_src inl) pragmaSrc (pprSpec (unLoc var)
diff --git a/compiler/hsSyn/HsDecls.hs b/compiler/hsSyn/HsDecls.hs
index f84fcfd5ec..db5510c706 100644
--- a/compiler/hsSyn/HsDecls.hs
+++ b/compiler/hsSyn/HsDecls.hs
@@ -10,6 +10,7 @@
 {-# LANGUAGE UndecidableInstances #-} -- Note [Pass sensitive types]
                                       -- in module PlaceHolder
 {-# LANGUAGE ConstraintKinds #-}
+{-# LANGUAGE FlexibleInstances #-}
 {-# LANGUAGE TypeFamilies #-}
 
 -- | Abstract syntax of global declarations.
@@ -577,14 +578,17 @@ type instance XFamDecl      (GhcPass _) = NoExt
 type instance XSynDecl      GhcPs = NoExt
 type instance XSynDecl      GhcRn = NameSet -- FVs
 type instance XSynDecl      GhcTc = NameSet -- FVs
+type instance XSynDecl      GhcSe = NoExt
 
 type instance XDataDecl     GhcPs = NoExt
 type instance XDataDecl     GhcRn = DataDeclRn
 type instance XDataDecl     GhcTc = DataDeclRn
+type instance XDataDecl     GhcSe = NoExt
 
 type instance XClassDecl    GhcPs = NoExt
 type instance XClassDecl    GhcRn = NameSet -- FVs
 type instance XClassDecl    GhcTc = NameSet -- FVs
+type instance XClassDecl    GhcSe = NoExt
 
 type instance XXTyClDecl    (GhcPass _) = NoExt
 
@@ -695,7 +699,6 @@ hsDeclHasCusk (XTyClDecl _) = panic "hsDeclHasCusk"
 -- ~~~~~~~~~~~~~~~~~~~~~~~~
 
 instance (p ~ GhcPass pass, OutputableBndrId p) => Outputable (TyClDecl p) where
-
     ppr (FamDecl { tcdFam = decl }) = ppr decl
     ppr (SynDecl { tcdLName = ltycon, tcdTyVars = tyvars, tcdFixity = fixity
                  , tcdRhs = rhs })
@@ -1868,6 +1871,7 @@ data DerivStrategy pass
 type instance XViaStrategy GhcPs = LHsSigType GhcPs
 type instance XViaStrategy GhcRn = LHsSigType GhcRn
 type instance XViaStrategy GhcTc = Type
+type instance XViaStrategy GhcSe = LHsSigType GhcSe
 
 instance (p ~ GhcPass pass, OutputableBndrId p)
         => Outputable (DerivStrategy p) where
@@ -1968,10 +1972,12 @@ data ForeignDecl pass
 type instance XForeignImport   GhcPs = NoExt
 type instance XForeignImport   GhcRn = NoExt
 type instance XForeignImport   GhcTc = Coercion
+type instance XForeignImport   GhcSe = NoExt
 
 type instance XForeignExport   GhcPs = NoExt
 type instance XForeignExport   GhcRn = NoExt
 type instance XForeignExport   GhcTc = Coercion
+type instance XForeignExport   GhcSe = NoExt
 
 type instance XXForeignDecl    (GhcPass _) = NoExt
 
@@ -2114,6 +2120,7 @@ data HsRuleRn = HsRuleRn NameSet NameSet -- Free-vars from the LHS and RHS
 type instance XHsRule       GhcPs = NoExt
 type instance XHsRule       GhcRn = HsRuleRn
 type instance XHsRule       GhcTc = HsRuleRn
+type instance XHsRule       GhcSe = NoExt
 
 type instance XXRuleDecl    (GhcPass _) = NoExt
 
diff --git a/compiler/hsSyn/HsExpr.hs b/compiler/hsSyn/HsExpr.hs
index 6ca37e07ce..72042690cd 100644
--- a/compiler/hsSyn/HsExpr.hs
+++ b/compiler/hsSyn/HsExpr.hs
@@ -10,7 +10,7 @@
                                       -- in module PlaceHolder
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE ExistentialQuantification #-}
-{-# LANGUAGE DeriveFunctor #-}
+{-# LANGUAGE DeriveFunctor, DeriveFoldable, DeriveTraversable #-}
 {-# LANGUAGE TypeFamilies #-}
 
 -- | Abstract Haskell syntax for expressions.
@@ -442,11 +442,11 @@ data HsExpr p
   --             'ApiAnnotation.AnnClose'
 
   -- For details on above see note [Api annotations] in ApiAnnotation
-  | HsDo        (XDo p)                  -- Type of the whole expression
-                (HsStmtContext Name)     -- The parameterisation is unimportant
-                                         -- because in this context we never use
-                                         -- the PatGuard or ParStmt variant
-                (Located [ExprLStmt p]) -- "do":one or more stmts
+  | HsDo        (XDo p)                    -- Type of the whole expression
+                (HsStmtContext (DoName p)) -- The parameterisation is unimportant
+                                           -- because in this context we never use
+                                           -- the PatGuard or ParStmt variant
+                (Located [ExprLStmt p])    -- "do":one or more stmts
 
   -- | Syntactic list: [a,b,c,...]
   --
@@ -476,7 +476,6 @@ data HsExpr p
   --
   --  - 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnOpen' @'{'@,
   --         'ApiAnnotation.AnnDotdot','ApiAnnotation.AnnClose' @'}'@
-
   -- For details on above see note [Api annotations] in ApiAnnotation
   | RecordUpd
       { rupd_ext  :: XRecordUpd p
@@ -719,10 +718,12 @@ type instance XApp           (GhcPass _) = NoExt
 type instance XAppTypeE      GhcPs = LHsWcType GhcPs
 type instance XAppTypeE      GhcRn = LHsWcType GhcRn
 type instance XAppTypeE      GhcTc = LHsWcType GhcRn
+type instance XAppTypeE      GhcSe = LHsWcType GhcSe
 
 type instance XOpApp         GhcPs = NoExt
 type instance XOpApp         GhcRn = Fixity
 type instance XOpApp         GhcTc = Fixity
+type instance XOpApp         GhcSe = NoExt
 
 type instance XNegApp        (GhcPass _) = NoExt
 type instance XPar           (GhcPass _) = NoExt
@@ -733,6 +734,7 @@ type instance XExplicitTuple (GhcPass _) = NoExt
 type instance XExplicitSum   GhcPs = NoExt
 type instance XExplicitSum   GhcRn = NoExt
 type instance XExplicitSum   GhcTc = [Type]
+type instance XExplicitSum   GhcSe = NoExt
 
 type instance XCase          (GhcPass _) = NoExt
 type instance XIf            (GhcPass _) = NoExt
@@ -740,32 +742,39 @@ type instance XIf            (GhcPass _) = NoExt
 type instance XMultiIf       GhcPs = NoExt
 type instance XMultiIf       GhcRn = NoExt
 type instance XMultiIf       GhcTc = Type
+type instance XMultiIf       GhcSe = NoExt
 
 type instance XLet           (GhcPass _) = NoExt
 
 type instance XDo            GhcPs = NoExt
 type instance XDo            GhcRn = NoExt
 type instance XDo            GhcTc = Type
+type instance XDo            GhcSe = NoExt
 
 type instance XExplicitList  GhcPs = NoExt
 type instance XExplicitList  GhcRn = NoExt
 type instance XExplicitList  GhcTc = Type
+type instance XExplicitList  GhcSe = NoExt
 
 type instance XRecordCon     GhcPs = NoExt
 type instance XRecordCon     GhcRn = NoExt
 type instance XRecordCon     GhcTc = RecordConTc
+type instance XRecordCon     GhcSe = NoExt
 
 type instance XRecordUpd     GhcPs = NoExt
 type instance XRecordUpd     GhcRn = NoExt
 type instance XRecordUpd     GhcTc = RecordUpdTc
+type instance XRecordUpd     GhcSe = NoExt
 
 type instance XExprWithTySig GhcPs = (LHsSigWcType GhcPs)
 type instance XExprWithTySig GhcRn = (LHsSigWcType GhcRn)
 type instance XExprWithTySig GhcTc = (LHsSigWcType GhcRn)
+type instance XExprWithTySig GhcSe = (LHsSigWcType GhcSe)
 
 type instance XArithSeq      GhcPs = NoExt
 type instance XArithSeq      GhcRn = NoExt
 type instance XArithSeq      GhcTc = PostTcExpr
+type instance XArithSeq      GhcSe = NoExt
 
 type instance XSCC           (GhcPass _) = NoExt
 type instance XCoreAnn       (GhcPass _) = NoExt
@@ -780,10 +789,12 @@ type instance XProc          (GhcPass _) = NoExt
 type instance XStatic        GhcPs = NoExt
 type instance XStatic        GhcRn = NameSet
 type instance XStatic        GhcTc = NameSet
+type instance XStatic        GhcSe = NoExt
 
 type instance XArrApp        GhcPs = NoExt
 type instance XArrApp        GhcRn = NoExt
 type instance XArrApp        GhcTc = Type
+type instance XArrApp        GhcSe = NoExt
 
 type instance XArrForm       (GhcPass _) = NoExt
 type instance XTick          (GhcPass _) = NoExt
@@ -820,6 +831,7 @@ type instance XPresent         (GhcPass _) = NoExt
 type instance XMissing         GhcPs = NoExt
 type instance XMissing         GhcRn = NoExt
 type instance XMissing         GhcTc = Type
+type instance XMissing         GhcSe = NoExt
 
 type instance XXTupArg         (GhcPass _) = NoExt
 
@@ -1393,6 +1405,7 @@ data HsCmd id
 type instance XCmdArrApp  GhcPs = NoExt
 type instance XCmdArrApp  GhcRn = NoExt
 type instance XCmdArrApp  GhcTc = Type
+type instance XCmdArrApp  GhcSe = NoExt
 
 type instance XCmdArrForm (GhcPass _) = NoExt
 type instance XCmdApp     (GhcPass _) = NoExt
@@ -1405,6 +1418,7 @@ type instance XCmdLet     (GhcPass _) = NoExt
 type instance XCmdDo      GhcPs = NoExt
 type instance XCmdDo      GhcRn = NoExt
 type instance XCmdDo      GhcTc = Type
+type instance XCmdDo      GhcSe = NoExt
 
 type instance XCmdWrap    (GhcPass _) = NoExt
 type instance XXCmd       (GhcPass _) = NoExt
@@ -1436,6 +1450,7 @@ data CmdTopTc
 type instance XCmdTop  GhcPs = NoExt
 type instance XCmdTop  GhcRn = CmdSyntaxTable GhcRn -- See Note [CmdSyntaxTable]
 type instance XCmdTop  GhcTc = CmdTopTc
+type instance XCmdTop  GhcSe = NoExt
 
 type instance XXCmdTop (GhcPass _) = NoExt
 
@@ -1586,6 +1601,7 @@ data MatchGroupTc
 type instance XMG         GhcPs b = NoExt
 type instance XMG         GhcRn b = NoExt
 type instance XMG         GhcTc b = MatchGroupTc
+type instance XMG         GhcSe b = NoExt
 
 type instance XXMatchGroup (GhcPass _) b = NoExt
 
@@ -1985,28 +2001,34 @@ type instance XLastStmt        (GhcPass _) (GhcPass _) b = NoExt
 type instance XBindStmt        (GhcPass _) GhcPs b = NoExt
 type instance XBindStmt        (GhcPass _) GhcRn b = NoExt
 type instance XBindStmt        (GhcPass _) GhcTc b = Type
+type instance XBindStmt        (GhcPass _) GhcSe b = NoExt
 
 type instance XApplicativeStmt (GhcPass _) GhcPs b = NoExt
 type instance XApplicativeStmt (GhcPass _) GhcRn b = NoExt
 type instance XApplicativeStmt (GhcPass _) GhcTc b = Type
+type instance XApplicativeStmt (GhcPass _) GhcSe b = NoExt
 
 type instance XBodyStmt        (GhcPass _) GhcPs b = NoExt
 type instance XBodyStmt        (GhcPass _) GhcRn b = NoExt
 type instance XBodyStmt        (GhcPass _) GhcTc b = Type
+type instance XBodyStmt        (GhcPass _) GhcSe b = NoExt
 
 type instance XLetStmt         (GhcPass _) (GhcPass _) b = NoExt
 
 type instance XParStmt         (GhcPass _) GhcPs b = NoExt
 type instance XParStmt         (GhcPass _) GhcRn b = NoExt
 type instance XParStmt         (GhcPass _) GhcTc b = Type
+type instance XParStmt         (GhcPass _) GhcSe b = NoExt
 
 type instance XTransStmt       (GhcPass _) GhcPs b = NoExt
 type instance XTransStmt       (GhcPass _) GhcRn b = NoExt
 type instance XTransStmt       (GhcPass _) GhcTc b = Type
+type instance XTransStmt       (GhcPass _) GhcSe b = NoExt
 
 type instance XRecStmt         (GhcPass _) GhcPs b = NoExt
 type instance XRecStmt         (GhcPass _) GhcRn b = NoExt
 type instance XRecStmt         (GhcPass _) GhcTc b = RecStmtTc
+type instance XRecStmt         (GhcPass _) GhcSe b = NoExt
 
 type instance XXStmtLR         (GhcPass _) (GhcPass _) b = NoExt
 
@@ -2705,7 +2727,7 @@ data HsMatchContext id -- Not an extensible tag
   | ThPatSplice            -- ^A Template Haskell pattern splice
   | ThPatQuote             -- ^A Template Haskell pattern quotation [p| (a,b) |]
   | PatSyn                 -- ^A pattern synonym declaration
-  deriving Functor
+  deriving (Functor, Foldable, Traversable)
 deriving instance (Data id) => Data (HsMatchContext id)
 
 instance OutputableBndr id => Outputable (HsMatchContext id) where
@@ -2722,6 +2744,7 @@ instance OutputableBndr id => Outputable (HsMatchContext id) where
   ppr ThPatQuote            = text "ThPatQuote"
   ppr PatSyn                = text "PatSyn"
 
+
 isPatSynCtxt :: HsMatchContext id -> Bool
 isPatSynCtxt ctxt =
   case ctxt of
@@ -2742,7 +2765,7 @@ data HsStmtContext id
   | PatGuard (HsMatchContext id)     -- ^Pattern guard for specified thing
   | ParStmtCtxt (HsStmtContext id)   -- ^A branch of a parallel stmt
   | TransStmtCtxt (HsStmtContext id) -- ^A branch of a transform stmt
-  deriving Functor
+  deriving (Functor, Foldable, Traversable)
 deriving instance (Data id) => Data (HsStmtContext id)
 
 isListCompExpr :: HsStmtContext id -> Bool
diff --git a/compiler/hsSyn/HsExpr.hs-boot b/compiler/hsSyn/HsExpr.hs-boot
index 109e9814e5..4b8c15dfc8 100644
--- a/compiler/hsSyn/HsExpr.hs-boot
+++ b/compiler/hsSyn/HsExpr.hs-boot
@@ -5,7 +5,7 @@
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE RoleAnnotations #-}
 {-# LANGUAGE ExistentialQuantification #-}
-{-# LANGUAGE TypeFamilies #-}
+{-# LANGUAGE TypeFamilies #-} -- needed to use OutputableBndrId
 
 module HsExpr where
 
diff --git a/compiler/hsSyn/HsExprBin.hs b/compiler/hsSyn/HsExprBin.hs
new file mode 100644
index 0000000000..7967f934fb
--- /dev/null
+++ b/compiler/hsSyn/HsExprBin.hs
@@ -0,0 +1,149 @@
+module HsExprBin
+  ( getModuleSplicesPath
+  , whenSet
+  , HsSpliceData(..)
+  , nonEmptyHsSpliceData
+  , emptyHsSpliceData
+  , SpliceResult(..)
+  , recordSpliceResult
+  , lookupSpliceResult
+  , exprSE2PS
+  , declSE2PS
+  , exprPS2SE
+  , declPS2SE
+  , handleUnsupported
+  ) where
+
+import Binary
+import GhcPrelude
+import HsDecls
+import HsExpr
+import HsExprBin_Conversions
+import qualified HsExprBin_ConversionSE2PS as SE2PS
+import qualified HsExprBin_ConversionPS2SE as PS2SE
+import HsExprBin_Instances ()
+import HsExtension
+import Module
+import Outputable
+import SrcLoc
+import TcRnTypes
+
+import qualified Data.Map.Strict as Map
+import System.FilePath
+
+{-
+
+Note [Serialisable AST phase]
+
+There is an AST phase called GhcSe, where 'Se' stands for Serialisable.
+It is quite close to GhcPs, in that it mostly represents ASTs the same way,
+except for (syntax-level) types and names, which are represented in a way
+that is (binary) serialisation friendly.
+
+The motivation for this new phase is to be able to serialise ASTs of Haskell
+code. (No existing phase has this property.) One use case would be to save
+ASTs resulting from the evaluation of Template Haskell code and to reuse them
+later, in place of evaluating the Template Haskell code. More generally,
+it seems useful to be able to persist or load parsed ASTs, may it be for
+IDE-style interactions or plugins.
+
+The purpose of the HsExprBin* modules is to define:
+- conversions from GhcSe to GhcPs, and back, with the four functions exported
+  by this module;
+- Binary instances for AST data types, only when "instantiated" at the GhcSe
+  phase.
+
+The former is done in two modules: HsExprBin_ConversionSE2PS and
+HsExprBin_ConversionPS2SE. The latter in HsExprBin_Instances.
+
+-}
+
+-- * .hs-splice file contents
+
+getModuleSplicesPath :: FilePath -> Module -> FilePath
+getModuleSplicesPath splicesDir m = splicesDir
+  </> toPath (moduleNameString (moduleName m)) <.> "hs-splice"
+
+  where toPath = map (\c -> if c == '.' then '/' else c)
+
+whenSet :: Monad m => Maybe a -> (a -> m b) -> m b -> m b
+whenSet m j n = maybe n j m
+
+newtype HsSpliceData = HsSpliceData { hsSpliceMap :: Map.Map SrcSpan SpliceResult }
+
+emptyHsSpliceData :: HsSpliceData
+emptyHsSpliceData = HsSpliceData Map.empty
+
+nonEmptyHsSpliceData :: HsSpliceData -> Bool
+nonEmptyHsSpliceData = not . Map.null . hsSpliceMap
+
+data SpliceResult
+  = SRExpr  (LHsExpr GhcSe)
+  | SRDecls [LHsDecl GhcSe] -- TODO: change to HsGroup ?
+  -- TODO: add patterns and types?
+
+instance Binary SpliceResult where
+  put_ bh r = case r of
+    SRExpr e -> putByte bh 0 >> put_ bh e
+    SRDecls ds -> putByte bh 1 >> put_ bh ds
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> SRExpr <$> get bh
+      1 -> SRDecls <$> get bh
+      _ -> panic "Binary SpliceResult: unknown tag"
+
+instance Binary HsSpliceData where
+  put_ bh (HsSpliceData m) = put_ bh (Map.toList m)
+  get bh = (\l -> HsSpliceData (Map.fromList l)) <$> get bh
+
+recordSpliceResult :: SrcSpan -> SpliceResult -> HsSpliceData -> HsSpliceData
+recordSpliceResult loc res (HsSpliceData m) = HsSpliceData (Map.insert loc res m)
+
+lookupSpliceResult :: SrcSpan -> HsSpliceData -> Maybe SpliceResult
+lookupSpliceResult loc (HsSpliceData m) = Map.lookup loc m
+
+-- * High-level conversion interface
+
+-- Converting Se -> Ps
+
+-- | Convert a serialisable expression AST to a parsed expression AST
+exprSE2PS :: LHsExpr GhcSe -> RnM (ConvResult (LHsExpr GhcPs))
+exprSE2PS = runConv . SE2PS.cvLHsExpr
+
+-- | Convert a serialisable declaration AST to a parsed declaration AST
+declSE2PS :: LHsDecl GhcSe -> RnM (ConvResult (LHsDecl GhcPs))
+declSE2PS = runConv . SE2PS.cvLHsDecl
+
+-- Converting Ps -> Se
+
+-- | Convert a parsed expression AST to a serialisable expression AST
+exprPS2SE :: LHsExpr GhcPs -> RnM (ConvResult (LHsExpr GhcSe))
+exprPS2SE = runConv . PS2SE.cvLHsExpr
+
+-- | Convert a parsed declaration AST to a serialisable expression AST
+declPS2SE :: LHsDecl GhcPs -> RnM (ConvResult (LHsDecl GhcSe))
+declPS2SE = runConv . PS2SE.cvLHsDecl
+
+-- * Error reporting
+
+-- | Panics with a nice error when we encounter an unsupported
+--   construct, or returns the actual result if the conversion
+--   succeeded.
+handleUnsupported
+  :: Located SDoc -- ^ TH expression that got evaluated
+  -> Maybe SDoc -- ^ code resulting from the evaluation of the 1st arg
+  -> ConvResult a -- ^ result of the conversion
+  -> RnM a
+handleUnsupported (L loc thDoc) resDoc convRes = case convRes of
+  ConvOK a -> pure a
+  ConvError (ConvUnsupported conName tyName subexprDoc) ->
+    pprPanic "HsExprBin.handleUnsupported" . vcat $
+      [ text "GHC encountered a Haskell construct not supported by -{load, save}-splices:"
+      , nest 4 $ subexprDoc <> text (" - constructor " ++ conName ++ " of type " ++ tyName)
+      , text "while evaluating the following expression from "  <> ppr loc <> text ":"
+      , nest 4 $ thDoc
+      ] ++
+      maybe [] (\d -> [text "which resulted in:" , nest 4 d]) resDoc
+
+  ConvError (ConvFailure errorStr) -> panic errorStr
diff --git a/compiler/hsSyn/HsExprBin.hs-boot b/compiler/hsSyn/HsExprBin.hs-boot
new file mode 100644
index 0000000000..964847e097
--- /dev/null
+++ b/compiler/hsSyn/HsExprBin.hs-boot
@@ -0,0 +1,4 @@
+module HsExprBin where
+
+data HsSpliceData
+emptyHsSpliceData :: HsSpliceData
\ No newline at end of file
diff --git a/compiler/hsSyn/HsExprBin_ConversionPS2SE.hs b/compiler/hsSyn/HsExprBin_ConversionPS2SE.hs
new file mode 100644
index 0000000000..839564fbfe
--- /dev/null
+++ b/compiler/hsSyn/HsExprBin_ConversionPS2SE.hs
@@ -0,0 +1,812 @@
+{-# LANGUAGE GADTs #-}
+module HsExprBin_ConversionPS2SE where
+
+import Control.Applicative
+import Data.Traversable
+
+import Bag (mapBagM)
+import Class
+import CoreSyn ( Tickish(..) )
+import GhcPrelude
+import HsBinds
+import HsDecls
+import HsExpr
+import HsExprBin_Conversions
+import HsExtension
+import HsLit
+import HsPat
+import HsTypes
+
+-- * Conversion from serialisable ASTs to parsed ASTs
+
+cvLHsDecl :: LHsDecl GhcPs -> Conv (LHsDecl GhcSe)
+cvLHsDecl = traverse cvHsDecl
+
+cvHsDecl :: HsDecl GhcPs -> Conv (HsDecl GhcSe)
+cvHsDecl (TyClD a b) = TyClD <$> pure a <*> cvTyClDecl b
+cvHsDecl (InstD a b) = InstD <$> pure a <*> cvInstDecl b
+cvHsDecl (DerivD a b) = DerivD <$> pure a <*> cvDerivDecl b
+cvHsDecl (ValD a b) = ValD <$> pure a <*> cvHsBindLR b
+cvHsDecl (SigD a b) = SigD <$> pure a <*> cvSig b
+cvHsDecl (DefD a b) = DefD <$> pure a <*> cvDefaultDecl b
+cvHsDecl (ForD a b) = ForD <$> pure a <*> cvForeignDecl b
+cvHsDecl (WarningD a b) = WarningD <$> pure a <*> cvWarningDecls b
+cvHsDecl (RoleAnnotD a b) = RoleAnnotD <$> pure a <*> cvRoleAnnotDecl b
+cvHsDecl (AnnD a b) = AnnD <$> pure a <*> cvAnnDecl b
+cvHsDecl (RuleD a b) = RuleD <$> pure a <*> cvRuleDecls b
+cvHsDecl (SpliceD a b) = SpliceD <$> pure a <*> cvSpliceDecl b
+cvHsDecl (DocD a b) = pure (DocD a b)
+cvHsDecl (XHsDecl a) = pure (XHsDecl a)
+
+cvAnnDecl :: AnnDecl GhcPs -> Conv (AnnDecl GhcSe)
+cvAnnDecl (HsAnnotation a b c d) =
+  HsAnnotation a b <$> cvAnnProvenance c <*> cvLHsExpr d
+cvAnnDecl (XAnnDecl a) = pure (XAnnDecl a)
+
+cvInstDecl :: InstDecl GhcPs -> Conv (InstDecl GhcSe)
+cvInstDecl (ClsInstD a b) = ClsInstD a <$> cvClsInstDecl b
+cvInstDecl (DataFamInstD a b) = DataFamInstD a <$> cvDataFamInstDecl b
+cvInstDecl (TyFamInstD a b) = TyFamInstD a <$> cvTyFamInstDecl b
+cvInstDecl (XInstDecl a) = pure (XInstDecl a)
+
+cvClsInstDecl :: ClsInstDecl GhcPs -> Conv (ClsInstDecl GhcSe)
+cvClsInstDecl (ClsInstDecl a b c d e f g) =
+  ClsInstDecl a
+    <$> cvHsImplicitBndrs (traverse cvType) b
+    <*> mapBagM (traverse cvHsBindLR) c
+    <*> traverse (traverse cvSig) d
+    <*> traverse (traverse cvTyFamInstDecl) e
+    <*> traverse (traverse cvDataFamInstDecl) f
+    <*> pure g
+cvClsInstDecl (XClsInstDecl a) = pure (XClsInstDecl a)
+
+cvDerivDecl :: DerivDecl GhcPs -> Conv (DerivDecl GhcSe)
+cvDerivDecl (DerivDecl a b c d) =
+  DerivDecl a <$> cvHsWildCardBndrs (cvHsImplicitBndrs $ traverse cvType) b
+              <*> traverse (traverse cvDerivStrategy) c
+              <*> pure d
+cvDerivDecl (XDerivDecl a) = pure (XDerivDecl a)
+
+cvDerivStrategy
+  :: DerivStrategy GhcPs -> Conv (DerivStrategy GhcSe)
+cvDerivStrategy StockStrategy = pure StockStrategy
+cvDerivStrategy AnyclassStrategy = pure AnyclassStrategy
+cvDerivStrategy NewtypeStrategy = pure NewtypeStrategy
+cvDerivStrategy (ViaStrategy a) = ViaStrategy
+  <$> cvHsImplicitBndrs (traverse cvType) a
+
+cvTyClDecl :: TyClDecl GhcPs -> Conv (TyClDecl GhcSe)
+cvTyClDecl (FamDecl a b) = FamDecl <$> pure a <*> cvFamilyDecl b
+cvTyClDecl (SynDecl a b c d e) =
+  SynDecl a
+    <$> convertName b
+    <*> cvLHsQTyVars c <*> pure d
+    <*> traverse cvType e
+cvTyClDecl (DataDecl a b c d e) =
+  DataDecl a
+    <$> convertName b
+    <*> cvLHsQTyVars c <*> pure d
+    <*> cvHsDataDefn e
+cvTyClDecl (ClassDecl a b c d e f g h i j k) =
+  ClassDecl a
+    <$> traverse (traverse (traverse cvType)) b
+    <*> convertName c
+    <*> cvLHsQTyVars d
+    <*> pure e
+    <*> traverse (traverse cvFunDep) f
+    <*> traverse (traverse cvSig) g
+    <*> mapBagM (traverse cvHsBindLR) h
+    <*> traverse (traverse cvFamilyDecl) i
+    <*> traverse (traverse $ cvFamEqn cvLHsQTyVars (traverse cvType)) j
+    <*> pure k
+cvTyClDecl (XTyClDecl a) = pure (XTyClDecl a)
+
+cvRoleAnnotDecl :: RoleAnnotDecl GhcPs -> Conv (RoleAnnotDecl GhcSe)
+cvRoleAnnotDecl (RoleAnnotDecl a b c) =
+  RoleAnnotDecl a <$> convertName b <*> pure c
+cvRoleAnnotDecl (XRoleAnnotDecl a) = pure (XRoleAnnotDecl a)
+
+cvRuleDecls :: RuleDecls GhcPs -> Conv (RuleDecls GhcSe)
+cvRuleDecls (HsRules a b c) = HsRules a b <$> traverse (traverse cvRuleDecl) c
+cvRuleDecls (XRuleDecls a) = pure (XRuleDecls a)
+
+cvRuleDecl :: RuleDecl GhcPs -> Conv (RuleDecl GhcSe)
+cvRuleDecl (HsRule a b c d e f) =
+  HsRule a b c <$> traverse (traverse cvRuleBndr) d
+               <*> cvLHsExpr e <*> cvLHsExpr f
+cvRuleDecl (XRuleDecl a) = pure (XRuleDecl a)
+
+cvSpliceDecl :: SpliceDecl GhcPs -> Conv (SpliceDecl GhcSe)
+cvSpliceDecl (SpliceDecl a b c) =
+  SpliceDecl a <$> traverse cvHsSplice b <*> pure c
+cvSpliceDecl (XSpliceDecl a) = pure (XSpliceDecl a)
+
+cvHsSplice :: HsSplice GhcPs -> Conv (HsSplice GhcSe)
+cvHsSplice (HsTypedSplice a b c d) =
+  HsTypedSplice a b <$> convertName c <*> cvLHsExpr d
+cvHsSplice (HsUntypedSplice a b c d) =
+  HsUntypedSplice a b <$> convertName c <*> cvLHsExpr d
+cvHsSplice (HsQuasiQuote a b c d e) =
+  HsQuasiQuote a <$> convertName b <*> convertName c <*> pure d <*> pure e
+cvHsSplice (HsSpliced {}) =
+  unsupported "HsSpliced" "HsSplice" (error "<not printable>")
+cvHsSplice (XSplice a) = pure (XSplice a)
+
+cvRuleBndr :: RuleBndr GhcPs -> Conv (RuleBndr GhcSe)
+cvRuleBndr (RuleBndr a b) = RuleBndr a <$> convertName b
+cvRuleBndr (RuleBndrSig a b c) =
+  RuleBndrSig a <$> convertName b <*> cvHsSigWcType c
+cvRuleBndr (XRuleBndr a) = pure (XRuleBndr a)
+
+cvFamEqn
+  :: ( XCFamEqn GhcPs a b ~ XCFamEqn GhcSe c d
+     , XXFamEqn GhcPs a b ~ XXFamEqn GhcSe c d
+     )
+  => (a -> Conv c)
+  -> (b -> Conv d)
+  -> FamEqn GhcPs a b
+  -> Conv (FamEqn GhcSe c d)
+cvFamEqn goPats goRhs (FamEqn a b c d e) =
+  FamEqn a <$> convertName b <*> goPats c <*> pure d <*> goRhs e
+cvFamEqn _ _ (XFamEqn a) = pure (XFamEqn a)
+
+cvFamilyDecl :: FamilyDecl GhcPs -> Conv (FamilyDecl GhcSe)
+cvFamilyDecl (FamilyDecl a b c d e f g) =
+  FamilyDecl a
+    <$> cvFamilyInfo b <*> convertName c
+    <*> cvLHsQTyVars d <*> pure e
+    <*> traverse cvFamilyResultSig f
+    <*> traverse (traverse cvInjectivityAnn) g
+cvFamilyDecl (XFamilyDecl a) = pure (XFamilyDecl a)
+
+cvAnnProvenance :: ConvertName a b => AnnProvenance a -> Conv (AnnProvenance b)
+cvAnnProvenance (ValueAnnProvenance a) = ValueAnnProvenance <$> convertName a
+cvAnnProvenance (TypeAnnProvenance a) = TypeAnnProvenance <$> convertName a
+cvAnnProvenance ModuleAnnProvenance = pure ModuleAnnProvenance
+
+cvInjectivityAnn
+  :: InjectivityAnn GhcPs -> Conv (InjectivityAnn GhcSe)
+cvInjectivityAnn (InjectivityAnn a b) =
+  InjectivityAnn <$> convertName a <*> convertName b
+
+cvFamilyResultSig
+  :: FamilyResultSig GhcPs -> Conv (FamilyResultSig GhcSe)
+cvFamilyResultSig (NoSig a) = pure (NoSig a)
+cvFamilyResultSig (KindSig a b) = KindSig a <$> traverse cvType b
+cvFamilyResultSig (TyVarSig a b) = TyVarSig a <$> traverse cvHsTyVarBndr b
+cvFamilyResultSig (XFamilyResultSig a) = pure (XFamilyResultSig a)
+
+cvFamilyInfo
+  :: FamilyInfo GhcPs -> Conv (FamilyInfo GhcSe)
+cvFamilyInfo DataFamily = pure DataFamily
+cvFamilyInfo OpenTypeFamily = pure OpenTypeFamily
+cvFamilyInfo (ClosedTypeFamily a) =
+  ClosedTypeFamily <$> traverse (traverse (traverse (cvFamInstEqn (traverse cvType)))) a
+
+cvFamInstEqn
+  :: ( XCFamEqn GhcPs (HsTyPats GhcPs) a
+       ~ XCFamEqn GhcSe (HsTyPats GhcSe) b
+     , XHsIB GhcPs (FamEqn GhcPs (HsTyPats p) a)
+       ~ XHsIB GhcSe (FamEqn GhcSe (HsTyPats GhcSe) b)
+     , XXFamEqn GhcPs (HsTyPats GhcPs) a
+       ~ XXFamEqn GhcSe (HsTyPats GhcSe) b
+     , XXHsImplicitBndrs GhcPs (FamEqn GhcPs (HsTyPats GhcPs) a)
+       ~ XXHsImplicitBndrs GhcSe (FamEqn GhcSe (HsTyPats GhcSe) b)
+     )
+  => (a -> Conv b)
+  -> FamInstEqn GhcPs a
+  -> Conv (FamInstEqn GhcSe b)
+cvFamInstEqn f = cvHsImplicitBndrs (cvFamEqn (traverse (traverse cvType)) f)
+
+cvFunDep :: ConvertName a b => FunDep a -> Conv (FunDep b)
+cvFunDep (xs, ys) = (,) <$> convertName xs <*> convertName ys
+
+cvLHsQTyVars :: LHsQTyVars GhcPs -> Conv (LHsQTyVars GhcSe)
+cvLHsQTyVars (HsQTvs a b) = HsQTvs a <$> traverse (traverse cvHsTyVarBndr) b
+cvLHsQTyVars (XLHsQTyVars a) = pure (XLHsQTyVars a)
+
+cvForeignDecl :: ForeignDecl GhcPs -> Conv (ForeignDecl GhcSe)
+cvForeignDecl (ForeignImport a b c d) =
+  ForeignImport a
+    <$> convertName b
+    <*> cvHsImplicitBndrs (traverse cvType) c
+    <*> pure d
+cvForeignDecl (ForeignExport a b c d) =
+  ForeignExport a
+    <$> convertName b
+    <*> cvHsImplicitBndrs (traverse cvType) c
+    <*> pure d
+cvForeignDecl (XForeignDecl a) = pure (XForeignDecl a)
+
+cvDefaultDecl :: DefaultDecl GhcPs -> Conv (DefaultDecl GhcSe)
+cvDefaultDecl (DefaultDecl a b) = DefaultDecl a <$> traverse (traverse cvType) b
+cvDefaultDecl (XDefaultDecl a) = pure (XDefaultDecl a)
+
+cvTyFamInstDecl
+  :: TyFamInstDecl GhcPs -> Conv (TyFamInstDecl GhcSe)
+cvTyFamInstDecl (TyFamInstDecl d) =
+  TyFamInstDecl <$> cvFamInstEqn (traverse cvType) d
+
+cvDataFamInstDecl
+  :: DataFamInstDecl GhcPs -> Conv (DataFamInstDecl GhcSe)
+cvDataFamInstDecl (DataFamInstDecl d) =
+  DataFamInstDecl <$> cvFamInstEqn cvHsDataDefn d
+
+cvHsDataDefn :: HsDataDefn GhcPs -> Conv (HsDataDefn GhcSe)
+cvHsDataDefn (HsDataDefn a b c d e f g) =
+  HsDataDefn a b
+    <$> traverse (traverse (traverse cvType)) c <*> pure d
+    <*> traverse (traverse cvType) e
+    <*> traverse (traverse cvConDecl) f <*> cvHsDeriving g
+cvHsDataDefn (XHsDataDefn a) = pure (XHsDataDefn a)
+
+cvConDecl :: ConDecl GhcPs -> Conv (ConDecl GhcSe)
+cvConDecl (ConDeclGADT a b c d e f g h) =
+  ConDeclGADT a
+    <$> convertName b
+    <*> pure c
+    <*> cvLHsQTyVars d
+    <*> traverse (traverse (traverse (traverse cvType))) e
+    <*> cvHsConDeclDetails f
+    <*> traverse cvType g
+    <*> pure h
+cvConDecl (ConDeclH98 a b c d e f g) =
+  ConDeclH98 a
+    <$> convertName b
+    <*> pure c
+    <*> traverse (traverse cvHsTyVarBndr) d
+    <*> traverse (traverse (traverse (traverse cvType))) e
+    <*> cvHsConDeclDetails f
+    <*> pure g
+cvConDecl (XConDecl a) = pure (XConDecl a)
+
+cvHsDeriving :: HsDeriving GhcPs -> Conv (HsDeriving GhcSe)
+cvHsDeriving = traverse (traverse (traverse cvHsDerivingClause))
+
+cvHsDerivingClause
+  :: HsDerivingClause GhcPs -> Conv (HsDerivingClause GhcSe)
+cvHsDerivingClause (HsDerivingClause a b c) =
+  HsDerivingClause a
+    <$> traverse (traverse cvDerivStrategy) b
+    <*> traverse (traverse (cvHsImplicitBndrs (traverse cvType))) c
+cvHsDerivingClause (XHsDerivingClause a) = pure (XHsDerivingClause a)
+
+cvHsConDeclDetails
+  :: HsConDeclDetails GhcPs -> Conv (HsConDeclDetails GhcSe)
+cvHsConDeclDetails =
+  cvHsConDetails (traverse cvType)
+                 (traverse (traverse (traverse cvConDeclField)))
+
+cvHsConDetails
+  :: (a -> Conv c) -> (b -> Conv d) -> HsConDetails a b -> Conv (HsConDetails c d)
+cvHsConDetails f _  (PrefixCon a) = PrefixCon <$> traverse f a
+cvHsConDetails _ g     (RecCon a) = RecCon    <$> g a
+cvHsConDetails f _ (InfixCon a b) = InfixCon  <$> f a <*> f b
+
+cvConDeclField :: ConDeclField GhcPs -> Conv (ConDeclField GhcSe)
+cvConDeclField (ConDeclField a b c d) =
+  ConDeclField a <$> traverse (traverse cvFieldOcc) b <*> traverse cvType c
+                 <*> pure d
+cvConDeclField (XConDeclField a) = pure (XConDeclField a)
+
+cvWarningDecls :: WarnDecls GhcPs -> Conv (WarnDecls GhcSe)
+cvWarningDecls (Warnings a b c) =
+  Warnings a b <$> traverse (traverse cvWarningDecl) c
+cvWarningDecls (XWarnDecls a) = pure (XWarnDecls a)
+
+cvWarningDecl :: WarnDecl GhcPs -> Conv (WarnDecl GhcSe)
+cvWarningDecl (Warning a b c) = Warning a <$> convertName b <*> pure c
+cvWarningDecl (XWarnDecl a) = pure (XWarnDecl a)
+
+-- expressions
+
+cvLHsExpr :: LHsExpr GhcPs -> Conv (LHsExpr GhcSe)
+cvLHsExpr = traverse cvHsExpr
+
+cvHsExpr :: HsExpr GhcPs -> Conv (HsExpr GhcSe)
+cvHsExpr e = case e of
+  HsVar a b -> HsVar a <$> convertName b
+  HsUnboundVar a b -> pure (HsUnboundVar a b)
+  HsConLikeOut a b -> pure (HsConLikeOut a b)
+  HsRecFld a b -> HsRecFld a <$> cvAFieldOcc b
+  HsOverLabel a b c -> HsOverLabel a <$> convertName b <*> pure c
+  HsIPVar a b -> pure (HsIPVar a b)
+  HsOverLit a b -> HsOverLit a <$> cvOverLit b
+  HsLit a b -> HsLit a <$> cvLit b
+  HsLam a b -> HsLam a <$> cvMatchGroup cvLHsExpr b
+  HsLamCase a b -> HsLamCase a <$> cvMatchGroup cvLHsExpr b
+  HsApp a b c -> HsApp a <$> cvLHsExpr b <*> cvLHsExpr c
+  HsAppType a b -> HsAppType <$> cvLHsWcType a <*> cvLHsExpr b
+  OpApp a b c d -> OpApp a <$> cvLHsExpr b <*> cvLHsExpr c <*> cvLHsExpr d
+  NegApp a b c -> NegApp a <$> cvLHsExpr b <*> cvSyntaxExpr c
+  HsPar a b -> HsPar a <$> cvLHsExpr b
+  SectionL a b c -> SectionL a <$> cvLHsExpr b <*> cvLHsExpr c
+  SectionR a b c -> SectionR a <$> cvLHsExpr b <*> cvLHsExpr c
+  ExplicitTuple a b c -> ExplicitTuple a <$> traverse (traverse cvHsTupArg) b
+                                         <*> pure c
+  ExplicitSum a b c d -> ExplicitSum a b c <$> cvLHsExpr d
+  ExplicitList a b c -> ExplicitList a <$> traverse cvSyntaxExpr b <*> traverse cvLHsExpr c
+  HsCase a b c -> HsCase a <$> cvLHsExpr b <*> cvMatchGroup cvLHsExpr c
+  HsIf a b c d e -> HsIf a <$> traverse cvSyntaxExpr b
+                           <*> cvLHsExpr c <*> cvLHsExpr d <*> cvLHsExpr e
+  HsMultiIf a b -> HsMultiIf a <$> traverse (traverse (cvGRHS cvLHsExpr)) b
+  HsLet a b c -> HsLet a <$> traverse cvHsLocalBinds b <*> cvLHsExpr c
+  HsDo a b c -> HsDo a
+    <$> convertName b <*> traverse (traverse (traverse (cvStmtLR cvLHsExpr))) c
+  RecordCon a b c -> RecordCon a <$> convertName b <*> cvRecordBinds c
+  RecordUpd a b c -> RecordUpd a <$> cvLHsExpr b
+                                 <*> traverse (traverse cvHsRecUpdField) c
+  ExprWithTySig a b -> ExprWithTySig <$> cvHsSigWcType a <*> cvLHsExpr b
+  ArithSeq a b c -> ArithSeq a <$> traverse cvSyntaxExpr b <*> cvArithSeqInfo c
+  HsSCC a b c d -> HsSCC a b c <$> cvLHsExpr d
+  HsCoreAnn a b c d -> HsCoreAnn a b c <$> cvLHsExpr d
+  HsStatic a b -> HsStatic a <$> cvLHsExpr b
+  EWildPat a -> pure (EWildPat a)
+  EAsPat a b c -> EAsPat a <$> convertName b <*> cvLHsExpr c
+  EViewPat a b c -> EViewPat a <$> cvLHsExpr b <*> cvLHsExpr c
+  ELazyPat a b -> ELazyPat a <$> cvLHsExpr b
+  HsProc a b c -> HsProc a <$> traverse cvPat b <*> traverse cvHsCmdTop c
+  HsBinTick a b c d -> HsBinTick a b c <$> cvLHsExpr d
+  HsTickPragma a b c d e -> HsTickPragma a b c d <$> cvLHsExpr e
+  HsSpliceE a b -> HsSpliceE a <$> cvHsSplice b
+  HsBracket a b -> HsBracket a <$> cvHsBracket b
+  HsTick a b c -> HsTick a <$> cvTickish b <*> cvLHsExpr c
+  XExpr a -> pure (XExpr a)
+  HsArrApp {} -> unsupported "HsArrApp" "HsExpr" (error "<not printable>")
+  HsArrForm {} -> unsupported "HsArrForm" "HsExpr" (error "<not printable>")
+  HsWrap {} -> unsupported "HsWrap" "HsExpr" (error "<not printable>")
+  HsRnBracketOut {} -> unsupported "HsRnBracketOut" "HsExpr" (error "<not printable>")
+  HsTcBracketOut {} -> unsupported "HsTcBracketOut" "HsExpr" (error "<not printable>")
+
+cvHsBracket :: HsBracket GhcPs -> Conv (HsBracket GhcSe)
+cvHsBracket (ExpBr a b) = ExpBr a <$> cvLHsExpr b
+cvHsBracket (PatBr a b) = PatBr a <$> traverse cvPat b
+cvHsBracket (DecBrL a b) = DecBrL a <$> traverse (traverse cvHsDecl) b
+cvHsBracket (DecBrG a b) = DecBrG a <$> cvHsGroup b
+cvHsBracket (TypBr a b) = TypBr a <$> traverse cvType b
+cvHsBracket (VarBr a b c) = VarBr a b <$> convertName c
+cvHsBracket (TExpBr a b) = TExpBr a <$> cvLHsExpr b
+cvHsBracket (XBracket a) = pure (XBracket a)
+
+cvTickish :: ConvertName a b => Tickish a -> Conv (Tickish b)
+cvTickish (ProfNote a b c) = pure (ProfNote a b c)
+cvTickish (HpcTick a b) = pure (HpcTick a b)
+cvTickish (Breakpoint a b) = Breakpoint a <$> convertName b
+cvTickish (SourceNote a b) = pure (SourceNote a b)
+
+cvHsGroup :: HsGroup GhcPs -> Conv (HsGroup GhcSe)
+cvHsGroup (HsGroup a b c d e f g h i j k l) = HsGroup a
+  <$> cvHsValBindsLR b <*> traverse (traverse cvSpliceDecl) c
+  <*> traverse cvTyClGroup d
+  <*> traverse (traverse cvDerivDecl) e
+  <*> traverse (traverse cvFixitySig) f
+  <*> traverse (traverse cvDefaultDecl) g
+  <*> traverse (traverse cvForeignDecl) h
+  <*> traverse (traverse cvWarningDecls) i
+  <*> traverse (traverse cvAnnDecl) j
+  <*> traverse (traverse cvRuleDecls) k
+  <*> pure l
+cvHsGroup (XHsGroup a) = pure (XHsGroup a)
+
+cvTyClGroup :: TyClGroup GhcPs -> Conv (TyClGroup GhcSe)
+cvTyClGroup (TyClGroup a b c d) = TyClGroup a
+  <$> traverse (traverse cvTyClDecl) b
+  <*> traverse (traverse cvRoleAnnotDecl) c
+  <*> traverse (traverse cvInstDecl) d
+cvTyClGroup (XTyClGroup a) = pure (XTyClGroup a)
+
+cvHsCmdTop :: HsCmdTop GhcPs -> Conv (HsCmdTop GhcSe)
+cvHsCmdTop (HsCmdTop a b) = HsCmdTop a <$> traverse cvHsCmd b
+cvHsCmdTop (XCmdTop a) = pure (XCmdTop a)
+
+cvHsCmd :: HsCmd GhcPs -> Conv (HsCmd GhcSe)
+cvHsCmd (HsCmdArrApp a b c d e) = HsCmdArrApp a
+  <$> cvLHsExpr b <*> cvLHsExpr c <*> pure d <*> pure e
+cvHsCmd (HsCmdArrForm a b c d e) = HsCmdArrForm a
+  <$> cvLHsExpr b <*> pure c <*> pure d
+  <*> traverse (traverse cvHsCmdTop) e
+cvHsCmd (HsCmdApp a b c) = HsCmdApp a <$> traverse cvHsCmd b <*> cvLHsExpr c
+cvHsCmd (HsCmdLam a b) = HsCmdLam a <$> cvMatchGroup (traverse cvHsCmd) b
+cvHsCmd (HsCmdPar a b) = HsCmdPar a <$> traverse cvHsCmd b
+cvHsCmd (HsCmdCase a b c) = HsCmdCase a
+  <$> cvLHsExpr b <*> cvMatchGroup (traverse cvHsCmd) c
+cvHsCmd (HsCmdIf a b c d e) = HsCmdIf a
+  <$> traverse cvSyntaxExpr b
+  <*> cvLHsExpr c
+  <*> traverse cvHsCmd d
+  <*> traverse cvHsCmd e
+cvHsCmd (HsCmdLet a b c) = HsCmdLet a
+  <$> traverse cvHsLocalBinds b <*> traverse cvHsCmd c
+cvHsCmd (HsCmdDo a b) = HsCmdDo a
+  <$> traverse (traverse (traverse (cvStmtLR (traverse cvHsCmd)))) b
+cvHsCmd (HsCmdWrap {}) = unsupported "HsCmdWrap" "HsCmd" (error "<not printable>")
+cvHsCmd (XCmd a) = pure (XCmd a)
+
+cvArithSeqInfo :: ArithSeqInfo GhcPs -> Conv (ArithSeqInfo GhcSe)
+cvArithSeqInfo (From e) = From <$> cvLHsExpr e
+cvArithSeqInfo (FromThen a b) = FromThen <$> cvLHsExpr a <*> cvLHsExpr b
+cvArithSeqInfo (FromTo a b) = FromTo <$> cvLHsExpr a <*> cvLHsExpr b
+cvArithSeqInfo (FromThenTo a b c) = FromThenTo <$> cvLHsExpr a <*> cvLHsExpr b <*> cvLHsExpr c
+
+cvHsTupArg :: HsTupArg GhcPs -> Conv (HsTupArg GhcSe)
+cvHsTupArg (Present a b) = Present a <$> cvLHsExpr b
+cvHsTupArg (Missing a) = pure (Missing a)
+cvHsTupArg (XTupArg a) = pure (XTupArg a)
+
+cvAFieldOcc
+  :: AmbiguousFieldOcc GhcPs -> Conv (AmbiguousFieldOcc GhcSe)
+cvAFieldOcc (Unambiguous a b) = Unambiguous a <$> convertName b
+cvAFieldOcc (Ambiguous a b) = Ambiguous a <$> convertName b
+cvAFieldOcc (XAmbiguousFieldOcc a) = pure (XAmbiguousFieldOcc a)
+
+cvOverLit :: HsOverLit GhcPs -> Conv (HsOverLit GhcSe)
+cvOverLit (OverLit a b c) = OverLit a b <$> cvHsExpr c
+cvOverLit (XOverLit a) = pure (XOverLit a)
+
+cvLit :: HsLit GhcPs -> Conv (HsLit GhcSe)
+cvLit (HsChar a b) = pure (HsChar a b)
+cvLit (HsCharPrim a b) = pure (HsCharPrim a b)
+cvLit (HsString a b) = pure (HsString a b)
+cvLit (HsStringPrim a b) = pure (HsStringPrim a b)
+cvLit (HsInt a b) = pure (HsInt a b)
+cvLit (HsIntPrim a b) = pure (HsIntPrim a b)
+cvLit (HsWordPrim a b) = pure (HsWordPrim a b)
+cvLit (HsInt64Prim a b) = pure (HsInt64Prim a b)
+cvLit (HsWord64Prim a b) = pure (HsWord64Prim a b)
+cvLit (HsInteger a b c) = HsInteger a b <$> convertType c
+cvLit (HsRat a b c) = HsRat a b <$> convertType c
+cvLit (HsFloatPrim a b) = pure (HsFloatPrim a b)
+cvLit (HsDoublePrim a b) = pure (HsDoublePrim a b)
+cvLit (XLit a) = pure (XLit a)
+
+cvMatchGroup
+  :: ( XMG GhcPs a ~ XMG GhcSe b
+     , XCMatch GhcPs a ~ XCMatch GhcSe b
+     , XCGRHSs GhcPs a ~ XCGRHSs GhcSe b
+     , XCGRHS GhcPs a ~ XCGRHS GhcSe b
+     , XXMatchGroup GhcPs a ~ XXMatchGroup GhcSe b
+     , XXMatch GhcPs a ~ XXMatch GhcSe b
+     , XXGRHSs GhcPs a ~ XXGRHSs GhcSe b
+     , XXGRHS GhcPs a ~ XXGRHS GhcSe b
+     )
+  => (a -> Conv b) -> MatchGroup GhcPs a -> Conv (MatchGroup GhcSe b)
+cvMatchGroup f (MG a b c) = MG a
+  <$> traverse (traverse (traverse (cvMatch f))) b
+  <*> pure c
+cvMatchGroup _ (XMatchGroup a) = pure (XMatchGroup a)
+
+cvMatch
+  :: ( XCMatch GhcPs a ~ XCMatch GhcSe b
+     , XCGRHSs GhcPs a ~ XCGRHSs GhcSe b
+     , XCGRHS GhcPs a ~ XCGRHS GhcSe b
+     , XXMatch GhcPs a ~ XXMatch GhcSe b
+     , XXGRHSs GhcPs a ~ XXGRHSs GhcSe b
+     , XXGRHS GhcPs a ~ XXGRHS GhcSe b
+     )
+  => (a -> Conv b) -> Match GhcPs a -> Conv (Match GhcSe b)
+cvMatch f (Match a b c d) = Match a
+   <$> convertName b <*> traverse (traverse cvPat) c <*> cvGRHSs f d
+cvMatch _ (XMatch a) = pure (XMatch a)
+
+cvPat :: Pat GhcPs -> Conv (Pat GhcSe)
+cvPat (WildPat a) = pure (WildPat a)
+cvPat (VarPat a b) = VarPat a <$> convertName b
+cvPat (LazyPat a b) = LazyPat a <$> traverse cvPat b
+cvPat (AsPat a b c) = AsPat a <$> convertName b <*> traverse cvPat c
+cvPat (ParPat a b) = ParPat a <$> traverse cvPat b
+cvPat (BangPat a b) = BangPat a <$> traverse cvPat b
+cvPat (ListPat a b) = ListPat a
+  <$> traverse (traverse cvPat) b
+cvPat (TuplePat a b c) = TuplePat a
+  <$> traverse (traverse cvPat) b
+  <*> pure c
+cvPat (SumPat a b c d) = SumPat a
+  <$> traverse cvPat b
+  <*> pure c <*> pure d
+cvPat (ConPatIn a b) = ConPatIn <$> convertName a <*> cvHsConPatDetails b
+cvPat (ViewPat a b c) = ViewPat a <$> cvLHsExpr b <*> traverse cvPat c
+cvPat (LitPat a b) = LitPat a <$> cvLit b
+cvPat (NPat a b c d) = NPat a
+  <$> traverse cvOverLit b <*> traverse cvSyntaxExpr c
+  <*> cvSyntaxExpr d
+cvPat (NPlusKPat a b c d e f) = NPlusKPat a
+  <$> convertName b
+  <*> traverse cvOverLit c <*> cvOverLit d
+  <*> cvSyntaxExpr e <*> cvSyntaxExpr f
+cvPat (SigPat a b) = SigPat <$> cvHsSigWcType a <*> traverse cvPat b
+cvPat (SplicePat a b) = SplicePat a <$> cvHsSplice b
+cvPat (CoPat {}) = unsupported "CoPat" "Pat" (error "<not printable>")
+cvPat (ConPatOut {}) = unsupported "ConPatOut" "Pat" (error "<not printable>")
+cvPat (XPat a) = pure (XPat a)
+
+cvGRHSs
+  :: ( XCGRHSs GhcPs a ~ XCGRHSs GhcSe b
+     , XCGRHS GhcPs a ~ XCGRHS GhcSe b
+     , XXGRHSs GhcPs a ~ XXGRHSs GhcSe b
+     , XXGRHS GhcPs a ~ XXGRHS GhcSe b
+     )
+  => (a -> Conv b) -> GRHSs GhcPs a -> Conv (GRHSs GhcSe b)
+cvGRHSs f (GRHSs a b c) = GRHSs a
+  <$> traverse (traverse (cvGRHS f)) b
+  <*> traverse cvHsLocalBinds c
+cvGRHSs _ (XGRHSs a) = pure (XGRHSs a)
+
+cvGRHS
+  :: ( XCGRHS GhcPs a ~ XCGRHS GhcSe b
+     , XXGRHS GhcPs a ~ XXGRHS GhcSe b
+     )
+  => (a -> Conv b) -> GRHS GhcPs a -> Conv (GRHS GhcSe b)
+cvGRHS f (GRHS a b c) = GRHS a
+  <$> traverse (traverse (cvStmtLR cvLHsExpr)) b <*> f c
+cvGRHS _ (XGRHS a) = pure (XGRHS a)
+
+cvHsLocalBinds
+  :: HsLocalBinds GhcPs -> Conv (HsLocalBinds GhcSe)
+cvHsLocalBinds (HsValBinds a b) = HsValBinds a <$> cvHsValBindsLR b
+cvHsLocalBinds (HsIPBinds a b) = HsIPBinds a <$> cvHsIPBinds b
+cvHsLocalBinds (EmptyLocalBinds a) = pure (EmptyLocalBinds a)
+cvHsLocalBinds (XHsLocalBindsLR a) = pure (XHsLocalBindsLR a)
+
+cvHsValBindsLR
+  :: HsValBindsLR GhcPs GhcPs -> Conv (HsValBindsLR GhcSe GhcSe)
+cvHsValBindsLR (ValBinds a b c) = ValBinds a
+  <$> mapBagM (traverse cvHsBindLR) b
+  <*> traverse (traverse cvSig) c
+cvHsValBindsLR (XValBindsLR _) =
+  unsupported "XValBindsLR" "HsValBindsLR" (error "<not printable>")
+
+cvHsConPatDetails
+  :: HsConPatDetails GhcPs -> Conv (HsConPatDetails GhcSe)
+cvHsConPatDetails (PrefixCon a) = PrefixCon <$> traverse (traverse cvPat) a
+cvHsConPatDetails (RecCon a) = RecCon <$> cvHsRecFieldsPat a
+cvHsConPatDetails (InfixCon a b) = InfixCon
+  <$> traverse cvPat a <*> traverse cvPat b
+
+cvHsRecFields
+  :: (thing -> Conv thing')
+  -> HsRecFields GhcPs thing
+  -> Conv (HsRecFields GhcSe thing')
+cvHsRecFields f (HsRecFields a b) =
+  HsRecFields <$> traverse (traverse (cvHsRecField' cvFieldOcc f)) a <*> pure b
+
+cvHsRecField'
+  :: (id -> Conv id')
+  -> (thing -> Conv thing')
+  -> HsRecField' id thing
+  -> Conv (HsRecField' id' thing')
+cvHsRecField' f g (HsRecField a b c) =
+  HsRecField <$> traverse f a <*> g b <*> pure c
+
+cvHsRecFieldsPat
+  :: HsRecFields GhcPs (LPat GhcPs) -> Conv (HsRecFields GhcSe (LPat GhcSe))
+cvHsRecFieldsPat = cvHsRecFields (traverse cvPat)
+
+cvHsRecUpdField
+  :: HsRecUpdField GhcPs -> Conv (HsRecUpdField GhcSe)
+cvHsRecUpdField = cvHsRecField' cvAFieldOcc cvLHsExpr
+
+cvRecordBinds
+  :: HsRecordBinds GhcPs -> Conv (HsRecordBinds GhcSe)
+cvRecordBinds = cvHsRecFields cvLHsExpr
+
+cvFieldOcc :: FieldOcc GhcPs -> Conv (FieldOcc GhcSe)
+cvFieldOcc (FieldOcc a b) = FieldOcc a <$> convertName b
+cvFieldOcc (XFieldOcc a) = pure (XFieldOcc a)
+
+cvStmtLR
+  :: ( XLastStmt GhcPs GhcPs a ~ XLastStmt GhcSe GhcSe b
+     , XBindStmt GhcPs GhcPs a ~ XBindStmt GhcSe GhcSe b
+     , XBodyStmt GhcPs GhcPs a ~ XBodyStmt GhcSe GhcSe b
+     , XApplicativeStmt GhcPs GhcPs a ~ XApplicativeStmt GhcSe GhcSe b
+     , XLetStmt GhcPs GhcPs a ~ XLetStmt GhcSe GhcSe b
+     , XRecStmt GhcPs GhcPs a ~ XRecStmt GhcSe GhcSe b
+     , XParStmt GhcPs GhcPs a ~ XParStmt GhcSe GhcSe b
+     , XTransStmt GhcPs GhcPs a ~ XTransStmt GhcSe GhcSe b
+     , XXStmtLR GhcPs GhcPs a ~ XXStmtLR GhcSe GhcSe b
+     )
+  => (a -> Conv b) -> StmtLR GhcPs GhcPs a -> Conv (StmtLR GhcSe GhcSe b)
+cvStmtLR k (LastStmt a b c d) = LastStmt a
+  <$> k b <*> pure c <*> cvSyntaxExpr d
+cvStmtLR k (BindStmt a b c d e) = BindStmt a
+  <$> traverse cvPat b <*> k c
+  <*> cvSyntaxExpr d <*> cvSyntaxExpr e
+cvStmtLR k (BodyStmt a b c d) = BodyStmt a
+  <$> k b <*> cvSyntaxExpr c
+  <*> cvSyntaxExpr d
+cvStmtLR _ (ApplicativeStmt a b c) = ApplicativeStmt a
+  <$> traverse
+        (\(se, aa) -> (,) <$> cvSyntaxExpr se <*> cvApplicativeArg aa)
+        b
+  <*> traverse cvSyntaxExpr c
+cvStmtLR _ (LetStmt a b) = LetStmt a <$> traverse cvHsLocalBinds b
+cvStmtLR k (RecStmt a b c d e f g) = RecStmt a
+  <$> traverse (traverse (cvStmtLR k)) b
+  <*> convertName c
+  <*> convertName d
+  <*> cvSyntaxExpr e
+  <*> cvSyntaxExpr f
+  <*> cvSyntaxExpr g
+cvStmtLR _ (ParStmt a b c d) = ParStmt a
+  <$> traverse cvParStmtBlock b
+  <*> cvHsExpr c
+  <*> cvSyntaxExpr d
+cvStmtLR _ (TransStmt a b c d e f g h i) = TransStmt a b
+  <$> traverse (traverse (cvStmtLR cvLHsExpr)) c
+  <*> traverse (\(x, y) -> (,) <$> convertName x <*> convertName y) d
+  <*> cvLHsExpr e
+  <*> traverse cvLHsExpr f
+  <*> cvSyntaxExpr g
+  <*> cvSyntaxExpr h
+  <*> cvHsExpr i
+cvStmtLR _ (XStmtLR a) = pure (XStmtLR a)
+
+cvParStmtBlock
+  :: ParStmtBlock GhcPs GhcPs -> Conv (ParStmtBlock GhcSe GhcSe)
+cvParStmtBlock (ParStmtBlock a b c d) = ParStmtBlock a
+  <$> traverse (traverse (cvStmtLR cvLHsExpr)) b
+  <*> convertName c
+  <*> cvSyntaxExpr d
+cvParStmtBlock (XParStmtBlock a) = pure (XParStmtBlock a)
+
+cvSyntaxExpr :: SyntaxExpr GhcPs -> Conv (SyntaxExpr GhcSe)
+cvSyntaxExpr (SyntaxExpr a b c) =
+  SyntaxExpr <$> cvHsExpr a <*> pure b <*> pure c
+
+cvHsIPBinds
+  :: HsIPBinds GhcPs -> Conv (HsIPBinds GhcSe)
+cvHsIPBinds (IPBinds a b) = IPBinds a <$> traverse (traverse cvIPBind) b
+cvHsIPBinds (XHsIPBinds a) = pure (XHsIPBinds a)
+
+cvIPBind :: IPBind GhcPs -> Conv (IPBind GhcSe)
+cvIPBind (IPBind a b c) = IPBind a <$> convertName b <*> cvLHsExpr c
+cvIPBind (XIPBind a) = pure (XIPBind a)
+
+cvHsBindLR
+  :: HsBindLR GhcPs GhcPs -> Conv (HsBindLR GhcSe GhcSe)
+cvHsBindLR (FunBind a b c d e) = FunBind a
+  <$> convertName b
+  <*> cvMatchGroup cvLHsExpr c
+  <*> pure d <*> pure e
+cvHsBindLR (PatBind a b c d ) = PatBind a
+  <$> traverse cvPat b <*> cvGRHSs cvLHsExpr c <*> pure d
+cvHsBindLR (VarBind a b c d) = VarBind a
+  <$> convertName b <*> cvLHsExpr c <*> pure d
+cvHsBindLR (PatSynBind a b) = PatSynBind a <$> cvPatSynBind b
+cvHsBindLR (AbsBinds {}) =
+  unsupported "AbsBind" "HsBindLR" (error "<not printable>")
+cvHsBindLR (XHsBindsLR a) = pure (XHsBindsLR a)
+
+cvHsWildCardBndrs
+  :: ( XHsWC GhcPs thing ~ XHsWC GhcSe thing'
+     , XXHsWildCardBndrs GhcPs thing ~ XXHsWildCardBndrs GhcSe thing'
+     )
+  => (thing -> Conv thing')
+  -> HsWildCardBndrs GhcPs thing
+  -> Conv (HsWildCardBndrs GhcSe thing')
+cvHsWildCardBndrs thingF (HsWC a b) = HsWC a <$> thingF b
+cvHsWildCardBndrs _ (XHsWildCardBndrs a) = pure (XHsWildCardBndrs a)
+
+cvLHsWcType
+  :: LHsWcType GhcPs -> Conv (LHsWcType GhcSe)
+cvLHsWcType = cvHsWildCardBndrs (traverse cvType)
+
+cvHsSigWcType
+  :: LHsSigWcType GhcPs -> Conv (LHsSigWcType GhcSe)
+cvHsSigWcType = cvHsWildCardBndrs (cvHsImplicitBndrs (traverse cvType))
+
+cvHsImplicitBndrs
+  :: ( XHsIB GhcPs thing ~ XHsIB GhcSe thing'
+     , XXHsImplicitBndrs GhcPs thing ~ XXHsImplicitBndrs GhcSe thing'
+     )
+  => (thing -> Conv thing')
+  -> HsImplicitBndrs GhcPs thing
+  -> Conv (HsImplicitBndrs GhcSe thing')
+cvHsImplicitBndrs f (HsIB a b) = HsIB a <$> f b
+cvHsImplicitBndrs _ (XHsImplicitBndrs a) = pure (XHsImplicitBndrs a)
+
+cvType :: HsType GhcPs -> Conv (HsType GhcSe)
+cvType (HsForAllTy a b c) = HsForAllTy a
+  <$> traverse (traverse cvHsTyVarBndr) b
+  <*> traverse cvType c
+cvType (HsQualTy a b c) = HsQualTy a
+  <$> traverse (traverse (traverse cvType)) b
+  <*> traverse cvType c
+cvType (HsTyVar a b c) = HsTyVar a b <$> convertName c
+cvType (HsAppTy a b c) = HsAppTy a
+  <$> traverse cvType b
+  <*> traverse cvType c
+cvType (HsFunTy a b c) = HsFunTy a
+  <$> traverse cvType b
+  <*> traverse cvType c
+cvType (HsListTy a b) = HsListTy a <$> traverse cvType b
+cvType (HsTupleTy a b c) = HsTupleTy a b <$> traverse (traverse cvType) c
+cvType (HsSumTy a b) = HsSumTy a <$> traverse (traverse cvType) b
+cvType (HsOpTy a b c d) = HsOpTy a
+  <$> traverse cvType b
+  <*> convertName c
+  <*> traverse cvType d
+cvType (HsParTy a b) = HsParTy a <$> traverse cvType b
+cvType (HsIParamTy a b c) = HsIParamTy a b <$> traverse cvType c
+cvType (HsKindSig a b c) = HsKindSig a
+  <$> traverse cvType b
+  <*> traverse cvType c
+cvType (HsBangTy a b c) = HsBangTy a b <$> traverse cvType c
+cvType (HsRecTy a b) = HsRecTy a <$> traverse (traverse cvConDeclField) b
+cvType (HsExplicitListTy a b c) = HsExplicitListTy a b
+  <$> traverse (traverse cvType) c
+cvType (HsExplicitTupleTy a b) = HsExplicitTupleTy a
+  <$> traverse (traverse cvType) b
+cvType (HsTyLit a b) = pure (HsTyLit a b)
+cvType (HsWildCardTy a) = pure (HsWildCardTy a)
+cvType (HsDocTy a b c) = HsDocTy a <$> traverse cvType b <*> pure c
+cvType (HsSpliceTy a b) = HsSpliceTy a <$> cvHsSplice b
+cvType (HsStarTy a b) = pure (HsStarTy a b)
+cvType (XHsType a) = pure (XHsType a)
+
+cvHsTyVarBndr
+  :: HsTyVarBndr GhcPs -> Conv (HsTyVarBndr GhcSe)
+cvHsTyVarBndr (UserTyVar a b) = UserTyVar a <$> convertName b
+cvHsTyVarBndr (KindedTyVar a b c) = KindedTyVar a
+  <$> convertName b
+  <*> traverse cvType c
+cvHsTyVarBndr (XTyVarBndr a) = pure (XTyVarBndr a)
+
+cvApplicativeArg
+  :: ApplicativeArg GhcPs -> Conv (ApplicativeArg GhcSe)
+cvApplicativeArg (ApplicativeArgOne a b c d) = ApplicativeArgOne a
+  <$> traverse cvPat b <*> cvLHsExpr c <*> pure d
+cvApplicativeArg (ApplicativeArgMany a b c d) = ApplicativeArgMany a
+  <$> traverse (traverse (cvStmtLR cvLHsExpr)) b <*> cvHsExpr c
+  <*> traverse cvPat d
+cvApplicativeArg (XApplicativeArg a) = pure (XApplicativeArg a)
+
+cvSig :: Sig GhcPs -> Conv (Sig GhcSe)
+cvSig (TypeSig a b c) = TypeSig a <$> convertName b <*> cvHsSigWcType c
+cvSig (PatSynSig a b c) = PatSynSig a
+  <$> convertName b <*> cvHsImplicitBndrs (traverse cvType) c
+cvSig (ClassOpSig a b c d) = ClassOpSig a b
+  <$> convertName c <*> cvHsImplicitBndrs (traverse cvType) d
+cvSig (InlineSig a b c) = InlineSig a <$> convertName b <*> pure c
+cvSig (FixSig a b) = FixSig a <$> cvFixitySig b
+cvSig (SpecSig a b c d) = SpecSig a
+  <$> convertName b
+  <*> traverse (cvHsImplicitBndrs (traverse cvType)) c
+  <*> pure d
+cvSig (SpecInstSig a b c) = SpecInstSig a b
+  <$> cvHsImplicitBndrs (traverse cvType) c
+cvSig (SCCFunSig a b c d) = SCCFunSig a b <$> convertName c <*> pure d
+cvSig (CompleteMatchSig a b c d) = CompleteMatchSig a b
+  <$> convertName c <*> convertName d
+cvSig (MinimalSig a b c) = MinimalSig a b <$> traverse (traverse convertName) c
+cvSig (IdSig {}) = unsupported "IdSig" "Sig" (error "<not printable>")
+cvSig (XSig a) = pure (XSig a)
+
+cvFixitySig :: FixitySig GhcPs -> Conv (FixitySig GhcSe)
+cvFixitySig (FixitySig a b c) = FixitySig a <$> convertName b <*> pure c
+cvFixitySig (XFixitySig a) = pure (XFixitySig a)
+
+cvPatSynBind :: PatSynBind GhcPs GhcPs -> Conv (PatSynBind GhcSe GhcSe)
+cvPatSynBind (PSB a b c d e) = PSB a
+  <$> convertName b
+  <*> cvHsPatSynDetails convertName c <*> traverse cvPat d
+  <*> cvHsPatSynDir e
+cvPatSynBind (XPatSynBind a) = pure (XPatSynBind a)
+
+cvHsPatSynDetails
+  :: (a -> Conv b)
+  -> HsPatSynDetails a
+  -> Conv (HsPatSynDetails b)
+cvHsPatSynDetails f = cvHsConDetails f (traverse (cvRecordPatSynField f))
+
+cvRecordPatSynField
+  :: (a -> Conv b)
+  -> RecordPatSynField a
+  -> Conv (RecordPatSynField b)
+cvRecordPatSynField f (RecordPatSynField a b) =
+  RecordPatSynField <$> f a <*> f b
+
+cvHsPatSynDir :: HsPatSynDir GhcPs -> Conv (HsPatSynDir GhcSe)
+cvHsPatSynDir Unidirectional = pure Unidirectional
+cvHsPatSynDir ImplicitBidirectional = pure ImplicitBidirectional
+cvHsPatSynDir (ExplicitBidirectional a) = ExplicitBidirectional
+  <$> cvMatchGroup cvLHsExpr a
diff --git a/compiler/hsSyn/HsExprBin_ConversionSE2PS.hs b/compiler/hsSyn/HsExprBin_ConversionSE2PS.hs
new file mode 100644
index 0000000000..8fbc941a71
--- /dev/null
+++ b/compiler/hsSyn/HsExprBin_ConversionSE2PS.hs
@@ -0,0 +1,813 @@
+{-# LANGUAGE GADTs #-}
+module HsExprBin_ConversionSE2PS where
+
+import Control.Applicative
+import Data.Traversable
+
+import Bag (mapBagM)
+import Class
+import CoreSyn ( Tickish(..) )
+import GhcPrelude
+import HsBinds
+import HsDecls
+import HsExpr
+import HsExprBin_Conversions
+import HsExtension
+import HsLit
+import HsPat
+import HsTypes
+
+-- * Conversion from serialisable ASTs to parsed ASTs
+
+cvLHsDecl :: LHsDecl GhcSe -> Conv (LHsDecl GhcPs)
+cvLHsDecl = traverse cvHsDecl
+
+cvHsDecl :: HsDecl GhcSe -> Conv (HsDecl GhcPs)
+cvHsDecl (TyClD a b) = TyClD <$> pure a <*> cvTyClDecl b
+cvHsDecl (InstD a b) = InstD <$> pure a <*> cvInstDecl b
+cvHsDecl (DerivD a b) = DerivD <$> pure a <*> cvDerivDecl b
+cvHsDecl (ValD a b) = ValD <$> pure a <*> cvHsBindLR b
+cvHsDecl (SigD a b) = SigD <$> pure a <*> cvSig b
+cvHsDecl (DefD a b) = DefD <$> pure a <*> cvDefaultDecl b
+cvHsDecl (ForD a b) = ForD <$> pure a <*> cvForeignDecl b
+cvHsDecl (WarningD a b) = WarningD <$> pure a <*> cvWarningDecls b
+cvHsDecl (RoleAnnotD a b) = RoleAnnotD <$> pure a <*> cvRoleAnnotDecl b
+cvHsDecl (AnnD a b) = AnnD <$> pure a <*> cvAnnDecl b
+cvHsDecl (RuleD a b) = RuleD <$> pure a <*> cvRuleDecls b
+cvHsDecl (SpliceD a b) = SpliceD <$> pure a <*> cvSpliceDecl b
+cvHsDecl (DocD a b) = pure (DocD a b)
+cvHsDecl (XHsDecl a) = pure (XHsDecl a)
+
+cvAnnDecl :: AnnDecl GhcSe -> Conv (AnnDecl GhcPs)
+cvAnnDecl (HsAnnotation a b c d) =
+  HsAnnotation a b <$> cvAnnProvenance c <*> cvLHsExpr d
+cvAnnDecl (XAnnDecl a) = pure (XAnnDecl a)
+
+cvInstDecl :: InstDecl GhcSe -> Conv (InstDecl GhcPs)
+cvInstDecl (ClsInstD a b) = ClsInstD a <$> cvClsInstDecl b
+cvInstDecl (DataFamInstD a b) = DataFamInstD a <$> cvDataFamInstDecl b
+cvInstDecl (TyFamInstD a b) = TyFamInstD a <$> cvTyFamInstDecl b
+cvInstDecl (XInstDecl a) = pure (XInstDecl a)
+
+cvClsInstDecl :: ClsInstDecl GhcSe -> Conv (ClsInstDecl GhcPs)
+cvClsInstDecl (ClsInstDecl a b c d e f g) =
+  ClsInstDecl a
+    <$> cvHsImplicitBndrs (traverse cvType) b
+    <*> mapBagM (traverse cvHsBindLR) c
+    <*> traverse (traverse cvSig) d
+    <*> traverse (traverse cvTyFamInstDecl) e
+    <*> traverse (traverse cvDataFamInstDecl) f
+    <*> pure g
+cvClsInstDecl (XClsInstDecl a) = pure (XClsInstDecl a)
+
+cvDerivDecl :: DerivDecl GhcSe -> Conv (DerivDecl GhcPs)
+cvDerivDecl (DerivDecl a b c d) =
+  DerivDecl a <$> cvHsWildCardBndrs (cvHsImplicitBndrs $ traverse cvType) b
+              <*> traverse (traverse cvDerivStrategy) c
+              <*> pure d
+cvDerivDecl (XDerivDecl a) = pure (XDerivDecl a)
+
+cvDerivStrategy
+  :: DerivStrategy GhcSe -> Conv (DerivStrategy GhcPs)
+cvDerivStrategy StockStrategy = pure StockStrategy
+cvDerivStrategy AnyclassStrategy = pure AnyclassStrategy
+cvDerivStrategy NewtypeStrategy = pure NewtypeStrategy
+cvDerivStrategy (ViaStrategy a) = ViaStrategy
+  <$> cvHsImplicitBndrs (traverse cvType) a
+
+cvTyClDecl :: TyClDecl GhcSe -> Conv (TyClDecl GhcPs)
+cvTyClDecl (FamDecl a b) = FamDecl <$> pure a <*> cvFamilyDecl b
+cvTyClDecl (SynDecl a b c d e) =
+  SynDecl a
+    <$> convertName b
+    <*> cvLHsQTyVars c <*> pure d
+    <*> traverse cvType e
+cvTyClDecl (DataDecl a b c d e) =
+  DataDecl a
+    <$> convertName b
+    <*> cvLHsQTyVars c <*> pure d
+    <*> cvHsDataDefn e
+cvTyClDecl (ClassDecl a b c d e f g h i j k) =
+  ClassDecl a
+    <$> traverse (traverse (traverse cvType)) b
+    <*> convertName c
+    <*> cvLHsQTyVars d
+    <*> pure e
+    <*> traverse (traverse cvFunDep) f
+    <*> traverse (traverse cvSig) g
+    <*> mapBagM (traverse cvHsBindLR) h
+    <*> traverse (traverse cvFamilyDecl) i
+    <*> traverse (traverse $ cvFamEqn cvLHsQTyVars (traverse cvType)) j
+    <*> pure k
+cvTyClDecl (XTyClDecl a) = pure (XTyClDecl a)
+
+cvRoleAnnotDecl :: RoleAnnotDecl GhcSe -> Conv (RoleAnnotDecl GhcPs)
+cvRoleAnnotDecl (RoleAnnotDecl a b c) =
+  RoleAnnotDecl a <$> convertName b <*> pure c
+cvRoleAnnotDecl (XRoleAnnotDecl a) = pure (XRoleAnnotDecl a)
+
+cvRuleDecls :: RuleDecls GhcSe -> Conv (RuleDecls GhcPs)
+cvRuleDecls (HsRules a b c) = HsRules a b <$> traverse (traverse cvRuleDecl) c
+cvRuleDecls (XRuleDecls a) = pure (XRuleDecls a)
+
+cvRuleDecl :: RuleDecl GhcSe -> Conv (RuleDecl GhcPs)
+cvRuleDecl (HsRule a b c d e f) =
+  HsRule a b c <$> traverse (traverse cvRuleBndr) d
+               <*> cvLHsExpr e <*> cvLHsExpr f
+cvRuleDecl (XRuleDecl a) = pure (XRuleDecl a)
+
+cvSpliceDecl :: SpliceDecl GhcSe -> Conv (SpliceDecl GhcPs)
+cvSpliceDecl (SpliceDecl a b c) =
+  SpliceDecl a <$> traverse cvHsSplice b <*> pure c
+cvSpliceDecl (XSpliceDecl a) = pure (XSpliceDecl a)
+
+cvHsSplice :: HsSplice GhcSe -> Conv (HsSplice GhcPs)
+cvHsSplice (HsTypedSplice a b c d) =
+  HsTypedSplice a b <$> convertName c <*> cvLHsExpr d
+cvHsSplice (HsUntypedSplice a b c d) =
+  HsUntypedSplice a b <$> convertName c <*> cvLHsExpr d
+cvHsSplice (HsQuasiQuote a b c d e) =
+  HsQuasiQuote a <$> convertName b <*> convertName c <*> pure d <*> pure e
+cvHsSplice (HsSpliced {}) =
+  unsupported "HsSpliced" "HsSplice" (error "<not printable>")
+cvHsSplice (XSplice a) = pure (XSplice a)
+
+cvRuleBndr :: RuleBndr GhcSe -> Conv (RuleBndr GhcPs)
+cvRuleBndr (RuleBndr a b) = RuleBndr a <$> convertName b
+cvRuleBndr (RuleBndrSig a b c) =
+  RuleBndrSig a <$> convertName b <*> cvHsSigWcType c
+cvRuleBndr (XRuleBndr a) = pure (XRuleBndr a)
+
+cvFamEqn
+  :: ( XCFamEqn GhcSe a b ~ XCFamEqn GhcPs c d
+     , XXFamEqn GhcSe a b ~ XXFamEqn GhcPs c d
+     )
+  => (a -> Conv c)
+  -> (b -> Conv d)
+  -> FamEqn GhcSe a b
+  -> Conv (FamEqn GhcPs c d)
+cvFamEqn goPats goRhs (FamEqn a b c d e) =
+  FamEqn a <$> convertName b <*> goPats c <*> pure d <*> goRhs e
+cvFamEqn _ _ (XFamEqn a) = pure (XFamEqn a)
+
+cvFamilyDecl :: FamilyDecl GhcSe -> Conv (FamilyDecl GhcPs)
+cvFamilyDecl (FamilyDecl a b c d e f g) =
+  FamilyDecl a
+    <$> cvFamilyInfo b <*> convertName c
+    <*> cvLHsQTyVars d <*> pure e
+    <*> traverse cvFamilyResultSig f
+    <*> traverse (traverse cvInjectivityAnn) g
+cvFamilyDecl (XFamilyDecl a) = pure (XFamilyDecl a)
+
+cvAnnProvenance :: ConvertName a b => AnnProvenance a -> Conv (AnnProvenance b)
+cvAnnProvenance (ValueAnnProvenance a) = ValueAnnProvenance <$> convertName a
+cvAnnProvenance (TypeAnnProvenance a) = TypeAnnProvenance <$> convertName a
+cvAnnProvenance ModuleAnnProvenance = pure ModuleAnnProvenance
+
+cvInjectivityAnn
+  :: InjectivityAnn GhcSe -> Conv (InjectivityAnn GhcPs)
+cvInjectivityAnn (InjectivityAnn a b) =
+  InjectivityAnn <$> convertName a <*> convertName b
+
+cvFamilyResultSig
+  :: FamilyResultSig GhcSe -> Conv (FamilyResultSig GhcPs)
+cvFamilyResultSig (NoSig a) = pure (NoSig a)
+cvFamilyResultSig (KindSig a b) = KindSig a <$> traverse cvType b
+cvFamilyResultSig (TyVarSig a b) = TyVarSig a <$> traverse cvHsTyVarBndr b
+cvFamilyResultSig (XFamilyResultSig a) = pure (XFamilyResultSig a)
+
+cvFamilyInfo
+  :: FamilyInfo GhcSe -> Conv (FamilyInfo GhcPs)
+cvFamilyInfo DataFamily = pure DataFamily
+cvFamilyInfo OpenTypeFamily = pure OpenTypeFamily
+cvFamilyInfo (ClosedTypeFamily a) =
+  ClosedTypeFamily <$> traverse (traverse (traverse (cvFamInstEqn (traverse cvType)))) a
+
+cvFamInstEqn
+  :: ( XCFamEqn GhcSe (HsTyPats GhcSe) a
+       ~ XCFamEqn GhcPs (HsTyPats GhcPs) b
+     , XHsIB GhcSe (FamEqn GhcSe (HsTyPats p) a)
+       ~ XHsIB GhcPs (FamEqn GhcPs (HsTyPats GhcPs) b)
+     , XXFamEqn GhcSe (HsTyPats GhcSe) a
+       ~ XXFamEqn GhcPs (HsTyPats GhcPs) b
+     , XXHsImplicitBndrs GhcSe (FamEqn GhcSe (HsTyPats GhcSe) a)
+       ~ XXHsImplicitBndrs GhcPs (FamEqn GhcPs (HsTyPats GhcPs) b)
+     )
+  => (a -> Conv b)
+  -> FamInstEqn GhcSe a
+  -> Conv (FamInstEqn GhcPs b)
+cvFamInstEqn f = cvHsImplicitBndrs (cvFamEqn (traverse (traverse cvType)) f)
+
+cvFunDep :: ConvertName a b => FunDep a -> Conv (FunDep b)
+cvFunDep (xs, ys) = (,) <$> convertName xs <*> convertName ys
+
+cvLHsQTyVars :: LHsQTyVars GhcSe -> Conv (LHsQTyVars GhcPs)
+cvLHsQTyVars (HsQTvs a b) = HsQTvs a <$> traverse (traverse cvHsTyVarBndr) b
+cvLHsQTyVars (XLHsQTyVars a) = pure (XLHsQTyVars a)
+
+cvForeignDecl :: ForeignDecl GhcSe -> Conv (ForeignDecl GhcPs)
+cvForeignDecl (ForeignImport a b c d) =
+  ForeignImport a
+    <$> convertName b
+    <*> cvHsImplicitBndrs (traverse cvType) c
+    <*> pure d
+cvForeignDecl (ForeignExport a b c d) =
+  ForeignExport a
+    <$> convertName b
+    <*> cvHsImplicitBndrs (traverse cvType) c
+    <*> pure d
+cvForeignDecl (XForeignDecl a) = pure (XForeignDecl a)
+
+cvDefaultDecl :: DefaultDecl GhcSe -> Conv (DefaultDecl GhcPs)
+cvDefaultDecl (DefaultDecl a b) = DefaultDecl a <$> traverse (traverse cvType) b
+cvDefaultDecl (XDefaultDecl a) = pure (XDefaultDecl a)
+
+cvTyFamInstDecl
+  :: TyFamInstDecl GhcSe -> Conv (TyFamInstDecl GhcPs)
+cvTyFamInstDecl (TyFamInstDecl d) =
+  TyFamInstDecl <$> cvFamInstEqn (traverse cvType) d
+
+cvDataFamInstDecl
+  :: DataFamInstDecl GhcSe -> Conv (DataFamInstDecl GhcPs)
+cvDataFamInstDecl (DataFamInstDecl d) =
+  DataFamInstDecl <$> cvFamInstEqn cvHsDataDefn d
+
+cvHsDataDefn :: HsDataDefn GhcSe -> Conv (HsDataDefn GhcPs)
+cvHsDataDefn (HsDataDefn a b c d e f g) =
+  HsDataDefn a b
+    <$> traverse (traverse (traverse cvType)) c <*> pure d
+    <*> traverse (traverse cvType) e
+    <*> traverse (traverse cvConDecl) f <*> cvHsDeriving g
+cvHsDataDefn (XHsDataDefn a) = pure (XHsDataDefn a)
+
+cvConDecl :: ConDecl GhcSe -> Conv (ConDecl GhcPs)
+cvConDecl (ConDeclGADT a b c d e f g h) =
+  ConDeclGADT a
+    <$> convertName b
+    <*> pure c
+    <*> cvLHsQTyVars d
+    <*> traverse (traverse (traverse (traverse cvType))) e
+    <*> cvHsConDeclDetails f
+    <*> traverse cvType g
+    <*> pure h
+cvConDecl (ConDeclH98 a b c d e f g) =
+  ConDeclH98 a
+    <$> convertName b
+    <*> pure c
+    <*> traverse (traverse cvHsTyVarBndr) d
+    <*> traverse (traverse (traverse (traverse cvType))) e
+    <*> cvHsConDeclDetails f
+    <*> pure g
+cvConDecl (XConDecl a) = pure (XConDecl a)
+
+cvHsDeriving :: HsDeriving GhcSe -> Conv (HsDeriving GhcPs)
+cvHsDeriving = traverse (traverse (traverse cvHsDerivingClause))
+
+cvHsDerivingClause
+  :: HsDerivingClause GhcSe -> Conv (HsDerivingClause GhcPs)
+cvHsDerivingClause (HsDerivingClause a b c) =
+  HsDerivingClause a
+    <$> traverse (traverse cvDerivStrategy) b
+    <*> traverse (traverse (cvHsImplicitBndrs (traverse cvType))) c
+cvHsDerivingClause (XHsDerivingClause a) = pure (XHsDerivingClause a)
+
+cvHsConDeclDetails
+  :: HsConDeclDetails GhcSe -> Conv (HsConDeclDetails GhcPs)
+cvHsConDeclDetails =
+  cvHsConDetails (traverse cvType)
+                 (traverse (traverse (traverse cvConDeclField)))
+
+cvHsConDetails
+  :: (a -> Conv c) -> (b -> Conv d) -> HsConDetails a b -> Conv (HsConDetails c d)
+cvHsConDetails f _  (PrefixCon a) = PrefixCon <$> traverse f a
+cvHsConDetails _ g     (RecCon a) = RecCon    <$> g a
+cvHsConDetails f _ (InfixCon a b) = InfixCon  <$> f a <*> f b
+
+cvConDeclField :: ConDeclField GhcSe -> Conv (ConDeclField GhcPs)
+cvConDeclField (ConDeclField a b c d) =
+  ConDeclField a <$> traverse (traverse cvFieldOcc) b <*> traverse cvType c
+                 <*> pure d
+cvConDeclField (XConDeclField a) = pure (XConDeclField a)
+
+cvWarningDecls :: WarnDecls GhcSe -> Conv (WarnDecls GhcPs)
+cvWarningDecls (Warnings a b c) =
+  Warnings a b <$> traverse (traverse cvWarningDecl) c
+cvWarningDecls (XWarnDecls a) = pure (XWarnDecls a)
+
+cvWarningDecl :: WarnDecl GhcSe -> Conv (WarnDecl GhcPs)
+cvWarningDecl (Warning a b c) = Warning a <$> convertName b <*> pure c
+cvWarningDecl (XWarnDecl a) = pure (XWarnDecl a)
+
+-- expressions
+
+cvLHsExpr :: LHsExpr GhcSe -> Conv (LHsExpr GhcPs)
+cvLHsExpr = traverse cvHsExpr
+
+cvHsExpr :: HsExpr GhcSe -> Conv (HsExpr GhcPs)
+cvHsExpr e = case e of
+  HsVar a b -> HsVar a <$> convertName b
+  HsUnboundVar a b -> pure (HsUnboundVar a b)
+  HsConLikeOut a b -> pure (HsConLikeOut a b)
+  HsRecFld a b -> HsRecFld a <$> cvAFieldOcc b
+  HsOverLabel a b c -> HsOverLabel a <$> convertName b <*> pure c
+  HsIPVar a b -> pure (HsIPVar a b)
+  HsOverLit a b -> HsOverLit a <$> cvOverLit b
+  HsLit a b -> HsLit a <$> cvLit b
+  HsLam a b -> HsLam a <$> cvMatchGroup cvLHsExpr b
+  HsLamCase a b -> HsLamCase a <$> cvMatchGroup cvLHsExpr b
+  HsApp a b c -> HsApp a <$> cvLHsExpr b <*> cvLHsExpr c
+  HsAppType a b -> HsAppType
+    <$> cvHsWildCardBndrs (traverse cvType) a <*> cvLHsExpr b
+  OpApp a b c d -> OpApp a <$> cvLHsExpr b <*> cvLHsExpr c <*> cvLHsExpr d
+  NegApp a b c -> NegApp a <$> cvLHsExpr b <*> cvSyntaxExpr c
+  HsPar a b -> HsPar a <$> cvLHsExpr b
+  SectionL a b c -> SectionL a <$> cvLHsExpr b <*> cvLHsExpr c
+  SectionR a b c -> SectionR a <$> cvLHsExpr b <*> cvLHsExpr c
+  ExplicitTuple a b c -> ExplicitTuple a <$> traverse (traverse cvHsTupArg) b
+                                         <*> pure c
+  ExplicitSum a b c d -> ExplicitSum a b c <$> cvLHsExpr d
+  ExplicitList a b c -> ExplicitList a <$> traverse cvSyntaxExpr b <*> traverse cvLHsExpr c
+  HsCase a b c -> HsCase a <$> cvLHsExpr b <*> cvMatchGroup cvLHsExpr c
+  HsIf a b c d e -> HsIf a <$> traverse cvSyntaxExpr b
+                           <*> cvLHsExpr c <*> cvLHsExpr d <*> cvLHsExpr e
+  HsMultiIf a b -> HsMultiIf a <$> traverse (traverse (cvGRHS cvLHsExpr)) b
+  HsLet a b c -> HsLet a <$> traverse cvHsLocalBinds b <*> cvLHsExpr c
+  HsDo a b c -> HsDo a
+    <$> convertName b <*> traverse (traverse (traverse (cvStmtLR cvLHsExpr))) c
+  RecordCon a b c -> RecordCon a <$> convertName b <*> cvRecordBinds c
+  RecordUpd a b c -> RecordUpd a <$> cvLHsExpr b
+                                 <*> traverse (traverse cvHsRecUpdField) c
+  ExprWithTySig a b -> ExprWithTySig <$> cvHsSigWcType a <*> cvLHsExpr b
+  ArithSeq a b c -> ArithSeq a <$> traverse cvSyntaxExpr b <*> cvArithSeqInfo c
+  HsSCC a b c d -> HsSCC a b c <$> cvLHsExpr d
+  HsCoreAnn a b c d -> HsCoreAnn a b c <$> cvLHsExpr d
+  HsStatic a b -> HsStatic a <$> cvLHsExpr b
+  EWildPat a -> pure (EWildPat a)
+  EAsPat a b c -> EAsPat a <$> convertName b <*> cvLHsExpr c
+  EViewPat a b c -> EViewPat a <$> cvLHsExpr b <*> cvLHsExpr c
+  ELazyPat a b -> ELazyPat a <$> cvLHsExpr b
+  HsProc a b c -> HsProc a <$> traverse cvPat b <*> traverse cvHsCmdTop c
+  HsBinTick a b c d -> HsBinTick a b c <$> cvLHsExpr d
+  HsTickPragma a b c d e -> HsTickPragma a b c d <$> cvLHsExpr e
+  HsSpliceE a b -> HsSpliceE a <$> cvHsSplice b
+  HsBracket a b -> HsBracket a <$> cvHsBracket b
+  HsTick a b c -> HsTick a <$> cvTickish b <*> cvLHsExpr c
+  XExpr a -> pure (XExpr a)
+  HsArrApp {} -> unsupported "HsArrApp" "HsExpr" (error "<not printable>")
+  HsArrForm {} -> unsupported "HsArrForm" "HsExpr" (error "<not printable>")
+  HsWrap {} -> unsupported "HsWrap" "HsExpr" (error "<not printable>")
+  HsRnBracketOut {} -> unsupported "HsRnBracketOut" "HsExpr" (error "<not printable>")
+  HsTcBracketOut {} -> unsupported "HsTcBracketOut" "HsExpr" (error "<not printable>")
+
+cvHsBracket :: HsBracket GhcSe -> Conv (HsBracket GhcPs)
+cvHsBracket (ExpBr a b) = ExpBr a <$> cvLHsExpr b
+cvHsBracket (PatBr a b) = PatBr a <$> traverse cvPat b
+cvHsBracket (DecBrL a b) = DecBrL a <$> traverse (traverse cvHsDecl) b
+cvHsBracket (DecBrG a b) = DecBrG a <$> cvHsGroup b
+cvHsBracket (TypBr a b) = TypBr a <$> traverse cvType b
+cvHsBracket (VarBr a b c) = VarBr a b <$> convertName c
+cvHsBracket (TExpBr a b) = TExpBr a <$> cvLHsExpr b
+cvHsBracket (XBracket a) = pure (XBracket a)
+
+cvTickish :: ConvertName a b => Tickish a -> Conv (Tickish b)
+cvTickish (ProfNote a b c) = pure (ProfNote a b c)
+cvTickish (HpcTick a b) = pure (HpcTick a b)
+cvTickish (Breakpoint a b) = Breakpoint a <$> convertName b
+cvTickish (SourceNote a b) = pure (SourceNote a b)
+
+cvHsGroup :: HsGroup GhcSe -> Conv (HsGroup GhcPs)
+cvHsGroup (HsGroup a b c d e f g h i j k l) = HsGroup a
+  <$> cvHsValBindsLR b <*> traverse (traverse cvSpliceDecl) c
+  <*> traverse cvTyClGroup d
+  <*> traverse (traverse cvDerivDecl) e
+  <*> traverse (traverse cvFixitySig) f
+  <*> traverse (traverse cvDefaultDecl) g
+  <*> traverse (traverse cvForeignDecl) h
+  <*> traverse (traverse cvWarningDecls) i
+  <*> traverse (traverse cvAnnDecl) j
+  <*> traverse (traverse cvRuleDecls) k
+  <*> pure l
+cvHsGroup (XHsGroup a) = pure (XHsGroup a)
+
+cvTyClGroup :: TyClGroup GhcSe -> Conv (TyClGroup GhcPs)
+cvTyClGroup (TyClGroup a b c d) = TyClGroup a
+  <$> traverse (traverse cvTyClDecl) b
+  <*> traverse (traverse cvRoleAnnotDecl) c
+  <*> traverse (traverse cvInstDecl) d
+cvTyClGroup (XTyClGroup a) = pure (XTyClGroup a)
+
+cvHsCmdTop :: HsCmdTop GhcSe -> Conv (HsCmdTop GhcPs)
+cvHsCmdTop (HsCmdTop a b) = HsCmdTop a <$> traverse cvHsCmd b
+cvHsCmdTop (XCmdTop a) = pure (XCmdTop a)
+
+cvHsCmd :: HsCmd GhcSe -> Conv (HsCmd GhcPs)
+cvHsCmd (HsCmdArrApp a b c d e) = HsCmdArrApp a
+  <$> cvLHsExpr b <*> cvLHsExpr c <*> pure d <*> pure e
+cvHsCmd (HsCmdArrForm a b c d e) = HsCmdArrForm a
+  <$> cvLHsExpr b <*> pure c <*> pure d
+  <*> traverse (traverse cvHsCmdTop) e
+cvHsCmd (HsCmdApp a b c) = HsCmdApp a <$> traverse cvHsCmd b <*> cvLHsExpr c
+cvHsCmd (HsCmdLam a b) = HsCmdLam a <$> cvMatchGroup (traverse cvHsCmd) b
+cvHsCmd (HsCmdPar a b) = HsCmdPar a <$> traverse cvHsCmd b
+cvHsCmd (HsCmdCase a b c) = HsCmdCase a
+  <$> cvLHsExpr b <*> cvMatchGroup (traverse cvHsCmd) c
+cvHsCmd (HsCmdIf a b c d e) = HsCmdIf a
+  <$> traverse cvSyntaxExpr b
+  <*> cvLHsExpr c
+  <*> traverse cvHsCmd d
+  <*> traverse cvHsCmd e
+cvHsCmd (HsCmdLet a b c) = HsCmdLet a
+  <$> traverse cvHsLocalBinds b <*> traverse cvHsCmd c
+cvHsCmd (HsCmdDo a b) = HsCmdDo a
+  <$> traverse (traverse (traverse (cvStmtLR (traverse cvHsCmd)))) b
+cvHsCmd (HsCmdWrap {}) = unsupported "HsCmdWrap" "HsCmd" (error "<not printable>")
+cvHsCmd (XCmd a) = pure (XCmd a)
+
+cvArithSeqInfo :: ArithSeqInfo GhcSe -> Conv (ArithSeqInfo GhcPs)
+cvArithSeqInfo (From e) = From <$> cvLHsExpr e
+cvArithSeqInfo (FromThen a b) = FromThen <$> cvLHsExpr a <*> cvLHsExpr b
+cvArithSeqInfo (FromTo a b) = FromTo <$> cvLHsExpr a <*> cvLHsExpr b
+cvArithSeqInfo (FromThenTo a b c) = FromThenTo <$> cvLHsExpr a <*> cvLHsExpr b <*> cvLHsExpr c
+
+cvHsTupArg :: HsTupArg GhcSe -> Conv (HsTupArg GhcPs)
+cvHsTupArg (Present a b) = Present a <$> cvLHsExpr b
+cvHsTupArg (Missing a) = pure (Missing a)
+cvHsTupArg (XTupArg a) = pure (XTupArg a)
+
+cvAFieldOcc
+  :: AmbiguousFieldOcc GhcSe -> Conv (AmbiguousFieldOcc GhcPs)
+cvAFieldOcc (Unambiguous a b) = Unambiguous a <$> convertName b
+cvAFieldOcc (Ambiguous a b) = Ambiguous a <$> convertName b
+cvAFieldOcc (XAmbiguousFieldOcc a) = pure (XAmbiguousFieldOcc a)
+
+cvOverLit :: HsOverLit GhcSe -> Conv (HsOverLit GhcPs)
+cvOverLit (OverLit a b c) = OverLit a b <$> cvHsExpr c
+cvOverLit (XOverLit a) = pure (XOverLit a)
+
+cvLit :: HsLit GhcSe -> Conv (HsLit GhcPs)
+cvLit (HsChar a b) = pure (HsChar a b)
+cvLit (HsCharPrim a b) = pure (HsCharPrim a b)
+cvLit (HsString a b) = pure (HsString a b)
+cvLit (HsStringPrim a b) = pure (HsStringPrim a b)
+cvLit (HsInt a b) = pure (HsInt a b)
+cvLit (HsIntPrim a b) = pure (HsIntPrim a b)
+cvLit (HsWordPrim a b) = pure (HsWordPrim a b)
+cvLit (HsInt64Prim a b) = pure (HsInt64Prim a b)
+cvLit (HsWord64Prim a b) = pure (HsWord64Prim a b)
+cvLit (HsInteger a b c) = HsInteger a b <$> convertType c
+cvLit (HsRat a b c) = HsRat a b <$> convertType c
+cvLit (HsFloatPrim a b) = pure (HsFloatPrim a b)
+cvLit (HsDoublePrim a b) = pure (HsDoublePrim a b)
+cvLit (XLit a) = pure (XLit a)
+
+cvMatchGroup
+  :: ( XMG GhcSe a ~ XMG GhcPs b
+     , XCMatch GhcSe a ~ XCMatch GhcPs b
+     , XCGRHSs GhcSe a ~ XCGRHSs GhcPs b
+     , XCGRHS GhcSe a ~ XCGRHS GhcPs b
+     , XXMatchGroup GhcSe a ~ XXMatchGroup GhcPs b
+     , XXMatch GhcSe a ~ XXMatch GhcPs b
+     , XXGRHSs GhcSe a ~ XXGRHSs GhcPs b
+     , XXGRHS GhcSe a ~ XXGRHS GhcPs b
+     )
+  => (a -> Conv b) -> MatchGroup GhcSe a -> Conv (MatchGroup GhcPs b)
+cvMatchGroup f (MG a b c) = MG a
+  <$> traverse (traverse (traverse (cvMatch f))) b
+  <*> pure c
+cvMatchGroup _ (XMatchGroup a) = pure (XMatchGroup a)
+
+cvMatch
+  :: ( XCMatch GhcSe a ~ XCMatch GhcPs b
+     , XCGRHSs GhcSe a ~ XCGRHSs GhcPs b
+     , XCGRHS GhcSe a ~ XCGRHS GhcPs b
+     , XXMatch GhcSe a ~ XXMatch GhcPs b
+     , XXGRHSs GhcSe a ~ XXGRHSs GhcPs b
+     , XXGRHS GhcSe a ~ XXGRHS GhcPs b
+     )
+  => (a -> Conv b) -> Match GhcSe a -> Conv (Match GhcPs b)
+cvMatch f (Match a b c d) = Match a
+   <$> convertName b <*> traverse (traverse cvPat) c <*> cvGRHSs f d
+cvMatch _ (XMatch a) = pure (XMatch a)
+
+cvPat :: Pat GhcSe -> Conv (Pat GhcPs)
+cvPat (WildPat a) = pure (WildPat a)
+cvPat (VarPat a b) = VarPat a <$> convertName b
+cvPat (LazyPat a b) = LazyPat a <$> traverse cvPat b
+cvPat (AsPat a b c) = AsPat a <$> convertName b <*> traverse cvPat c
+cvPat (ParPat a b) = ParPat a <$> traverse cvPat b
+cvPat (BangPat a b) = BangPat a <$> traverse cvPat b
+cvPat (ListPat a b) = ListPat a
+  <$> traverse (traverse cvPat) b
+cvPat (TuplePat a b c) = TuplePat a
+  <$> traverse (traverse cvPat) b
+  <*> pure c
+cvPat (SumPat a b c d) = SumPat a
+  <$> traverse cvPat b
+  <*> pure c <*> pure d
+cvPat (ConPatIn a b) = ConPatIn <$> convertName a <*> cvHsConPatDetails b
+cvPat (ViewPat a b c) = ViewPat a <$> cvLHsExpr b <*> traverse cvPat c
+cvPat (LitPat a b) = LitPat a <$> cvLit b
+cvPat (NPat a b c d) = NPat a
+  <$> traverse cvOverLit b <*> traverse cvSyntaxExpr c
+  <*> cvSyntaxExpr d
+cvPat (NPlusKPat a b c d e f) = NPlusKPat a
+  <$> convertName b
+  <*> traverse cvOverLit c <*> cvOverLit d
+  <*> cvSyntaxExpr e <*> cvSyntaxExpr f
+cvPat (SigPat a b) = SigPat <$> cvHsSigWcType a <*> traverse cvPat b
+cvPat (SplicePat a b) = SplicePat a <$> cvHsSplice b
+cvPat (CoPat {}) = unsupported "CoPat" "Pat" (error "<not printable>")
+cvPat (ConPatOut {}) = unsupported "ConPatOut" "Pat" (error "<not printable>")
+cvPat (XPat a) = pure (XPat a)
+
+cvGRHSs
+  :: ( XCGRHSs GhcSe a ~ XCGRHSs GhcPs b
+     , XCGRHS GhcSe a ~ XCGRHS GhcPs b
+     , XXGRHSs GhcSe a ~ XXGRHSs GhcPs b
+     , XXGRHS GhcSe a ~ XXGRHS GhcPs b
+     )
+  => (a -> Conv b) -> GRHSs GhcSe a -> Conv (GRHSs GhcPs b)
+cvGRHSs f (GRHSs a b c) = GRHSs a
+  <$> traverse (traverse (cvGRHS f)) b
+  <*> traverse cvHsLocalBinds c
+cvGRHSs _ (XGRHSs a) = pure (XGRHSs a)
+
+cvGRHS
+  :: ( XCGRHS GhcSe a ~ XCGRHS GhcPs b
+     , XXGRHS GhcSe a ~ XXGRHS GhcPs b
+     )
+  => (a -> Conv b) -> GRHS GhcSe a -> Conv (GRHS GhcPs b)
+cvGRHS f (GRHS a b c) = GRHS a
+  <$> traverse (traverse (cvStmtLR cvLHsExpr)) b <*> f c
+cvGRHS _ (XGRHS a) = pure (XGRHS a)
+
+cvHsLocalBinds
+  :: HsLocalBinds GhcSe -> Conv (HsLocalBinds GhcPs)
+cvHsLocalBinds (HsValBinds a b) = HsValBinds a <$> cvHsValBindsLR b
+cvHsLocalBinds (HsIPBinds a b) = HsIPBinds a <$> cvHsIPBinds b
+cvHsLocalBinds (EmptyLocalBinds a) = pure (EmptyLocalBinds a)
+cvHsLocalBinds (XHsLocalBindsLR a) = pure (XHsLocalBindsLR a)
+
+cvHsValBindsLR
+  :: HsValBindsLR GhcSe GhcSe -> Conv (HsValBindsLR GhcPs GhcPs)
+cvHsValBindsLR (ValBinds a b c) = ValBinds a
+  <$> mapBagM (traverse cvHsBindLR) b
+  <*> traverse (traverse cvSig) c
+cvHsValBindsLR (XValBindsLR _) =
+  unsupported "XValBindsLR" "HsValBindsLR" (error "<not printable>")
+
+cvHsConPatDetails
+  :: HsConPatDetails GhcSe -> Conv (HsConPatDetails GhcPs)
+cvHsConPatDetails (PrefixCon a) = PrefixCon <$> traverse (traverse cvPat) a
+cvHsConPatDetails (RecCon a) = RecCon <$> cvHsRecFieldsPat a
+cvHsConPatDetails (InfixCon a b) = InfixCon
+  <$> traverse cvPat a <*> traverse cvPat b
+
+cvHsRecFields
+  :: (thing -> Conv thing')
+  -> HsRecFields GhcSe thing
+  -> Conv (HsRecFields GhcPs thing')
+cvHsRecFields f (HsRecFields a b) =
+  HsRecFields <$> traverse (traverse (cvHsRecField' cvFieldOcc f)) a <*> pure b
+
+cvHsRecField'
+  :: (id -> Conv id')
+  -> (thing -> Conv thing')
+  -> HsRecField' id thing
+  -> Conv (HsRecField' id' thing')
+cvHsRecField' f g (HsRecField a b c) =
+  HsRecField <$> traverse f a <*> g b <*> pure c
+
+cvHsRecFieldsPat
+  :: HsRecFields GhcSe (LPat GhcSe) -> Conv (HsRecFields GhcPs (LPat GhcPs))
+cvHsRecFieldsPat = cvHsRecFields (traverse cvPat)
+
+cvHsRecUpdField
+  :: HsRecUpdField GhcSe -> Conv (HsRecUpdField GhcPs)
+cvHsRecUpdField = cvHsRecField' cvAFieldOcc cvLHsExpr
+
+cvRecordBinds
+  :: HsRecordBinds GhcSe -> Conv (HsRecordBinds GhcPs)
+cvRecordBinds = cvHsRecFields cvLHsExpr
+
+cvFieldOcc :: FieldOcc GhcSe -> Conv (FieldOcc GhcPs)
+cvFieldOcc (FieldOcc a b) = FieldOcc a <$> convertName b
+cvFieldOcc (XFieldOcc a) = pure (XFieldOcc a)
+
+cvStmtLR
+  :: ( XLastStmt GhcSe GhcSe a ~ XLastStmt GhcPs GhcPs b
+     , XBindStmt GhcSe GhcSe a ~ XBindStmt GhcPs GhcPs b
+     , XBodyStmt GhcSe GhcSe a ~ XBodyStmt GhcPs GhcPs b
+     , XApplicativeStmt GhcSe GhcSe a ~ XApplicativeStmt GhcPs GhcPs b
+     , XLetStmt GhcSe GhcSe a ~ XLetStmt GhcPs GhcPs b
+     , XRecStmt GhcSe GhcSe a ~ XRecStmt GhcPs GhcPs b
+     , XParStmt GhcSe GhcSe a ~ XParStmt GhcPs GhcPs b
+     , XTransStmt GhcSe GhcSe a ~ XTransStmt GhcPs GhcPs b
+     , XXStmtLR GhcSe GhcSe a ~ XXStmtLR GhcPs GhcPs b
+     )
+  => (a -> Conv b) -> StmtLR GhcSe GhcSe a -> Conv (StmtLR GhcPs GhcPs b)
+cvStmtLR k (LastStmt a b c d) = LastStmt a
+  <$> k b <*> pure c <*> cvSyntaxExpr d
+cvStmtLR k (BindStmt a b c d e) = BindStmt a
+  <$> traverse cvPat b <*> k c
+  <*> cvSyntaxExpr d <*> cvSyntaxExpr e
+cvStmtLR k (BodyStmt a b c d) = BodyStmt a
+  <$> k b <*> cvSyntaxExpr c
+  <*> cvSyntaxExpr d
+cvStmtLR _ (ApplicativeStmt a b c) = ApplicativeStmt a
+  <$> traverse
+        (\(se, aa) -> (,) <$> cvSyntaxExpr se <*> cvApplicativeArg aa)
+        b
+  <*> traverse cvSyntaxExpr c
+cvStmtLR _ (LetStmt a b) = LetStmt a <$> traverse cvHsLocalBinds b
+cvStmtLR k (RecStmt a b c d e f g) = RecStmt a
+  <$> traverse (traverse (cvStmtLR k)) b
+  <*> convertName c
+  <*> convertName d
+  <*> cvSyntaxExpr e
+  <*> cvSyntaxExpr f
+  <*> cvSyntaxExpr g
+cvStmtLR _ (ParStmt a b c d) = ParStmt a
+  <$> traverse cvParStmtBlock b
+  <*> cvHsExpr c
+  <*> cvSyntaxExpr d
+cvStmtLR _ (TransStmt a b c d e f g h i) = TransStmt a b
+  <$> traverse (traverse (cvStmtLR cvLHsExpr)) c
+  <*> traverse (\(x, y) -> (,) <$> convertName x <*> convertName y) d
+  <*> cvLHsExpr e
+  <*> traverse cvLHsExpr f
+  <*> cvSyntaxExpr g
+  <*> cvSyntaxExpr h
+  <*> cvHsExpr i
+cvStmtLR _ (XStmtLR a) = pure (XStmtLR a)
+
+cvParStmtBlock
+  :: ParStmtBlock GhcSe GhcSe -> Conv (ParStmtBlock GhcPs GhcPs)
+cvParStmtBlock (ParStmtBlock a b c d) = ParStmtBlock a
+  <$> traverse (traverse (cvStmtLR cvLHsExpr)) b
+  <*> convertName c
+  <*> cvSyntaxExpr d
+cvParStmtBlock (XParStmtBlock a) = pure (XParStmtBlock a)
+
+cvSyntaxExpr :: SyntaxExpr GhcSe -> Conv (SyntaxExpr GhcPs)
+cvSyntaxExpr (SyntaxExpr a b c) =
+  SyntaxExpr <$> cvHsExpr a <*> pure b <*> pure c
+
+cvHsIPBinds
+  :: HsIPBinds GhcSe -> Conv (HsIPBinds GhcPs)
+cvHsIPBinds (IPBinds a b) = IPBinds a <$> traverse (traverse cvIPBind) b
+cvHsIPBinds (XHsIPBinds a) = pure (XHsIPBinds a)
+
+cvIPBind :: IPBind GhcSe -> Conv (IPBind GhcPs)
+cvIPBind (IPBind a b c) = IPBind a <$> convertName b <*> cvLHsExpr c
+cvIPBind (XIPBind a) = pure (XIPBind a)
+
+cvHsBindLR
+  :: HsBindLR GhcSe GhcSe -> Conv (HsBindLR GhcPs GhcPs)
+cvHsBindLR (FunBind a b c d e) = FunBind a
+  <$> convertName b
+  <*> cvMatchGroup cvLHsExpr c
+  <*> pure d <*> pure e
+cvHsBindLR (PatBind a b c d ) = PatBind a
+  <$> traverse cvPat b <*> cvGRHSs cvLHsExpr c <*> pure d
+cvHsBindLR (VarBind a b c d) = VarBind a
+  <$> convertName b <*> cvLHsExpr c <*> pure d
+cvHsBindLR (PatSynBind a b) = PatSynBind a <$> cvPatSynBind b
+cvHsBindLR (AbsBinds {}) =
+  unsupported "AbsBind" "HsBindLR" (error "<not printable>")
+cvHsBindLR (XHsBindsLR a) = pure (XHsBindsLR a)
+
+cvHsWildCardBndrs
+  :: ( XHsWC GhcSe thing ~ XHsWC GhcPs thing'
+     , XXHsWildCardBndrs GhcSe thing ~ XXHsWildCardBndrs GhcPs thing'
+     )
+  => (thing -> Conv thing')
+  -> HsWildCardBndrs GhcSe thing
+  -> Conv (HsWildCardBndrs GhcPs thing')
+cvHsWildCardBndrs thingF (HsWC a b) = HsWC a <$> thingF b
+cvHsWildCardBndrs _ (XHsWildCardBndrs a) = pure (XHsWildCardBndrs a)
+
+cvLHsWcType
+  :: LHsWcType GhcSe -> Conv (LHsWcType GhcPs)
+cvLHsWcType = cvHsWildCardBndrs (traverse cvType)
+
+cvHsSigWcType
+  :: LHsSigWcType GhcSe -> Conv (LHsSigWcType GhcPs)
+cvHsSigWcType = cvHsWildCardBndrs (cvHsImplicitBndrs (traverse cvType))
+
+cvHsImplicitBndrs
+  :: ( XHsIB GhcSe thing ~ XHsIB GhcPs thing'
+     , XXHsImplicitBndrs GhcSe thing ~ XXHsImplicitBndrs GhcPs thing'
+     )
+  => (thing -> Conv thing')
+  -> HsImplicitBndrs GhcSe thing
+  -> Conv (HsImplicitBndrs GhcPs thing')
+cvHsImplicitBndrs f (HsIB a b) = HsIB a <$> f b
+cvHsImplicitBndrs _ (XHsImplicitBndrs a) = pure (XHsImplicitBndrs a)
+
+cvType :: HsType GhcSe -> Conv (HsType GhcPs)
+cvType (HsForAllTy a b c) = HsForAllTy a
+  <$> traverse (traverse cvHsTyVarBndr) b
+  <*> traverse cvType c
+cvType (HsQualTy a b c) = HsQualTy a
+  <$> traverse (traverse (traverse cvType)) b
+  <*> traverse cvType c
+cvType (HsTyVar a b c) = HsTyVar a b <$> convertName c
+cvType (HsAppTy a b c) = HsAppTy a
+  <$> traverse cvType b
+  <*> traverse cvType c
+cvType (HsFunTy a b c) = HsFunTy a
+  <$> traverse cvType b
+  <*> traverse cvType c
+cvType (HsListTy a b) = HsListTy a <$> traverse cvType b
+cvType (HsTupleTy a b c) = HsTupleTy a b <$> traverse (traverse cvType) c
+cvType (HsSumTy a b) = HsSumTy a <$> traverse (traverse cvType) b
+cvType (HsOpTy a b c d) = HsOpTy a
+  <$> traverse cvType b
+  <*> convertName c
+  <*> traverse cvType d
+cvType (HsParTy a b) = HsParTy a <$> traverse cvType b
+cvType (HsIParamTy a b c) = HsIParamTy a b <$> traverse cvType c
+cvType (HsKindSig a b c) = HsKindSig a
+  <$> traverse cvType b
+  <*> traverse cvType c
+cvType (HsBangTy a b c) = HsBangTy a b <$> traverse cvType c
+cvType (HsRecTy a b) = HsRecTy a <$> traverse (traverse cvConDeclField) b
+cvType (HsExplicitListTy a b c) = HsExplicitListTy a b
+  <$> traverse (traverse cvType) c
+cvType (HsExplicitTupleTy a b) = HsExplicitTupleTy a
+  <$> traverse (traverse cvType) b
+cvType (HsTyLit a b) = pure (HsTyLit a b)
+cvType (HsWildCardTy a) = pure (HsWildCardTy a)
+cvType (HsDocTy a b c) = HsDocTy a <$> traverse cvType b <*> pure c
+cvType (HsSpliceTy a b) = HsSpliceTy a <$> cvHsSplice b
+cvType (HsStarTy a b) = pure (HsStarTy a b)
+cvType (XHsType a) = pure (XHsType a)
+
+cvHsTyVarBndr
+  :: HsTyVarBndr GhcSe -> Conv (HsTyVarBndr GhcPs)
+cvHsTyVarBndr (UserTyVar a b) = UserTyVar a <$> convertName b
+cvHsTyVarBndr (KindedTyVar a b c) = KindedTyVar a
+  <$> convertName b
+  <*> traverse cvType c
+cvHsTyVarBndr (XTyVarBndr a) = pure (XTyVarBndr a)
+
+cvApplicativeArg
+  :: ApplicativeArg GhcSe -> Conv (ApplicativeArg GhcPs)
+cvApplicativeArg (ApplicativeArgOne a b c d) = ApplicativeArgOne a
+  <$> traverse cvPat b <*> cvLHsExpr c <*> pure d
+cvApplicativeArg (ApplicativeArgMany a b c d) = ApplicativeArgMany a
+  <$> traverse (traverse (cvStmtLR cvLHsExpr)) b <*> cvHsExpr c
+  <*> traverse cvPat d
+cvApplicativeArg (XApplicativeArg a) = pure (XApplicativeArg a)
+
+cvSig :: Sig GhcSe -> Conv (Sig GhcPs)
+cvSig (TypeSig a b c) = TypeSig a <$> convertName b <*> cvHsSigWcType c
+cvSig (PatSynSig a b c) = PatSynSig a
+  <$> convertName b <*> cvHsImplicitBndrs (traverse cvType) c
+cvSig (ClassOpSig a b c d) = ClassOpSig a b
+  <$> convertName c <*> cvHsImplicitBndrs (traverse cvType) d
+cvSig (InlineSig a b c) = InlineSig a <$> convertName b <*> pure c
+cvSig (FixSig a b) = FixSig a <$> cvFixitySig b
+cvSig (SpecSig a b c d) = SpecSig a
+  <$> convertName b
+  <*> traverse (cvHsImplicitBndrs (traverse cvType)) c
+  <*> pure d
+cvSig (SpecInstSig a b c) = SpecInstSig a b
+  <$> cvHsImplicitBndrs (traverse cvType) c
+cvSig (SCCFunSig a b c d) = SCCFunSig a b <$> convertName c <*> pure d
+cvSig (CompleteMatchSig a b c d) = CompleteMatchSig a b
+  <$> convertName c <*> convertName d
+cvSig (MinimalSig a b c) = MinimalSig a b <$> traverse (traverse convertName) c
+cvSig (IdSig {}) = unsupported "IdSig" "Sig" (error "<not printable>")
+cvSig (XSig a) = pure (XSig a)
+
+cvFixitySig :: FixitySig GhcSe -> Conv (FixitySig GhcPs)
+cvFixitySig (FixitySig a b c) = FixitySig a <$> convertName b <*> pure c
+cvFixitySig (XFixitySig a) = pure (XFixitySig a)
+
+cvPatSynBind :: PatSynBind GhcSe GhcSe -> Conv (PatSynBind GhcPs GhcPs)
+cvPatSynBind (PSB a b c d e) = PSB a
+  <$> convertName b
+  <*> cvHsPatSynDetails convertName c <*> traverse cvPat d
+  <*> cvHsPatSynDir e
+cvPatSynBind (XPatSynBind a) = pure (XPatSynBind a)
+
+cvHsPatSynDetails
+  :: (a -> Conv b)
+  -> HsPatSynDetails a
+  -> Conv (HsPatSynDetails b)
+cvHsPatSynDetails f = cvHsConDetails f (traverse (cvRecordPatSynField f))
+
+cvRecordPatSynField
+  :: (a -> Conv b)
+  -> RecordPatSynField a
+  -> Conv (RecordPatSynField b)
+cvRecordPatSynField f (RecordPatSynField a b) =
+  RecordPatSynField <$> f a <*> f b
+
+cvHsPatSynDir :: HsPatSynDir GhcSe -> Conv (HsPatSynDir GhcPs)
+cvHsPatSynDir Unidirectional = pure Unidirectional
+cvHsPatSynDir ImplicitBidirectional = pure ImplicitBidirectional
+cvHsPatSynDir (ExplicitBidirectional a) = ExplicitBidirectional
+  <$> cvMatchGroup cvLHsExpr a
diff --git a/compiler/hsSyn/HsExprBin_Conversions.hs b/compiler/hsSyn/HsExprBin_Conversions.hs
new file mode 100644
index 0000000000..df2d8f929a
--- /dev/null
+++ b/compiler/hsSyn/HsExprBin_Conversions.hs
@@ -0,0 +1,211 @@
+{-# LANGUAGE ConstraintKinds, DeriveFunctor #-}
+{-# LANGUAGE FlexibleContexts, FlexibleInstances #-}
+{-# LANGUAGE MultiParamTypeClasses #-}
+{-# LANGUAGE TypeFamilies, TypeSynonymInstances #-}
+module HsExprBin_Conversions where
+
+import Control.Applicative
+import Control.Monad
+import Control.Monad.IO.Class
+import Data.Char (isDigit)
+import Data.List (intercalate)
+import Data.Maybe
+import Data.Traversable
+
+import DynFlags
+import FastString
+import GhcPrelude
+import HsExpr
+import Module
+import Name
+import Outputable
+import PackageConfig
+import Packages
+import RdrName
+import SeName
+import SrcLoc
+import TcRnTypes
+import IfaceType
+import ToIface (toIfaceType)
+import TyCoRep (Type(..), TyLit(..))
+
+data ConvError
+  = ConvUnsupported String String SDoc
+  -- constructor name, type name, text rendering
+  -- of the unsupported subexpression
+  | ConvFailure String
+
+data ConvResult a
+  = ConvError ConvError
+  | ConvOK a
+  deriving Functor
+-- * Conversion utilities
+
+newtype Conv a = Conv { runConv :: RnM (ConvResult a) }
+
+instance Functor Conv where
+  fmap f (Conv k) = Conv (fmap (fmap f) k)
+
+instance Applicative Conv where
+  pure = Conv . return . ConvOK
+  (<*>) = ap
+
+instance Monad Conv where
+  return = pure
+
+  Conv mx >>= f = Conv $ mx >>= \cvx -> case cvx of
+    ConvOK x    -> runConv (f x)
+    ConvError e -> pure (ConvError e)
+
+unsupported :: String -- ^ constructor name
+            -> String -- ^ type name
+            -> SDoc   -- ^ textual rendering of the unsupported subexpression
+            -> Conv a
+unsupported con ty subexpr = Conv $
+  pure (ConvError $ ConvUnsupported con ty subexpr)
+
+badInput :: String -> Conv a
+badInput str = Conv $ pure (ConvError $ ConvFailure str)
+
+liftRn :: RnM a -> Conv a
+liftRn = Conv . fmap ConvOK
+
+class ConvertType t u where
+  convertType :: t -> Conv u
+
+class ConvertName a b where
+  convertName :: a -> Conv b
+
+instance ConvertName a b => ConvertName (Located a) (Located b) where
+  convertName = traverse convertName
+
+instance ConvertName a b => ConvertName [a] [b] where
+  convertName = traverse convertName
+
+instance ConvertName a b => ConvertName (Either e a) (Either e b) where
+  convertName = traverse convertName
+
+instance ConvertName a b => ConvertName (HsMatchContext a) (HsMatchContext b) where
+  convertName = traverse convertName
+
+instance ConvertName a b => ConvertName (HsStmtContext a) (HsStmtContext b) where
+  convertName = traverse convertName
+
+instance ConvertName a b => ConvertName (Maybe a) (Maybe b) where
+  convertName = traverse convertName
+
+instance ConvertType a a where
+  convertType = pure
+
+instance ConvertType Type IfaceType where
+  convertType = pure . toIfaceType
+
+instance ConvertType IfaceType Type where
+  convertType (IfaceLitTy n) = pure $ LitTy (go n)
+    where go (IfaceNumTyLit a) = NumTyLit a
+          go (IfaceStrTyLit a) = StrTyLit a
+  convertType e@(IfaceFreeTyVar {}) = unsupported "IfaceFreeTyVar" "IfaceType" (ppr e)
+  convertType e@(IfaceTyVar {}) = unsupported "IfaceTyVar" "IfaceType" (ppr e)
+  convertType e@(IfaceAppTy {}) = unsupported "IfaceAppTy" "IfaceType" (ppr e)
+  convertType e@(IfaceFunTy {}) = unsupported "IfaceFunTy" "IfaceType" (ppr e)
+  convertType e@(IfaceDFunTy {}) = unsupported "IfaceDFunTy" "IfaceType" (ppr e)
+  convertType e@(IfaceForAllTy {}) = unsupported "IfaceForAllTy" "IfaceType" (ppr e)
+  convertType e@(IfaceTyConApp {}) = unsupported "IfaceTyConApp" "IfaceType" (ppr e)
+  convertType e@(IfaceCastTy {}) = unsupported "IfaceCastTy" "IfaceType" (ppr e)
+  convertType e@(IfaceCoercionTy {}) = unsupported "IfaceCoercion" "IfaceType" (ppr e)
+  convertType e@(IfaceTupleTy {}) = unsupported "IfaceTupleTy" "IfaceType" (ppr e)
+
+
+instance ConvertName RdrName SeName where
+  convertName = pure . mkSeName
+
+instance ConvertName SeName RdrName where
+  convertName (SeName n) = case n of
+    Orig mod occn -> do
+      -- TODO: introduce some caching here, to avoid doing the
+      --       searchPackageId dance too often.
+      currentMod <- liftRn getModule
+
+      if samePackages currentMod mod
+        then let newMod = mod { moduleUnitId = moduleUnitId currentMod } in
+               pure (Orig newMod occn)
+        else do mnewmod <- liftRn (findEquivalentModule mod)
+                case mnewmod of
+                  Nothing   -> pure (Orig mod occn)
+                  Just mod' -> pure (Orig mod' occn)
+
+    _             -> pure n
+
+    where samePackages mod1 mod2 = fromMaybe False $ do -- maybe monad
+            let str1 = unitIdString (moduleUnitId mod1)
+                str2 = unitIdString (moduleUnitId mod2)
+            (pkg1, ver1, _mhash1) <- parseUnitId' str1
+            (pkg2, ver2, _mhash2) <- parseUnitId' str2
+            return (pkg1 == pkg2 && ver1 == ver2)
+
+instance ConvertName Name SeName where
+  convertName n = pure $ mkSeName (nameRdrName n)
+
+instance ConvertName SeName Name where
+  convertName (SeName n) = case isExact_maybe n of
+    Just a -> pure a
+    _      -> badInput "convertName :: SeName -> Name: non exact RdrName in SeName"
+
+-- * Looking up modules/packages for Orig names
+
+-- this rejects wired in packages, because we want to leave them untouched
+parseUnitId' :: String -> Maybe (String, String, Maybe String)
+parseUnitId' = parse
+
+  where
+    parse s = case splitOn '-' (reverse s) of
+      ("":_) -> Nothing
+      xs | length xs >= 1 && last xs == "" -> Nothing
+      (hash:ver:name) | isVersion ver ->
+         Just (intercalate "-" (reverse name), ver, Just hash)
+      (ver:name) | isVersion ver ->
+         Just (intercalate "-" (reverse name), ver, Nothing)
+      _ -> Nothing
+    splitOn c = go []
+      where go acc (x:xs)
+              | x == c    = acc : go "" xs
+              | otherwise = go (x:acc) xs
+            go acc [] = [acc]
+    isVersion = go False
+      -- True: waiting for digit or dot (we've seen a digit last)
+      -- False: waiting for digit (we've just seen a dot)
+      where go False (c:cs)
+              | isDigit c = go True cs
+              | otherwise = False
+            go True (c:cs)
+              | isDigit c = go True cs
+              | c == '.'  = go False cs
+              | otherwise = False
+            go b [] = b -- if we've seen a dot last (False), we fail
+                        -- otherwise, the version number can end here
+
+-- | Look up the module from the same package, but built by the
+--   current compiler, therefore with a slightly different hash
+--   in the unit id than the input Module, which was built by some
+--   non-cross-compiling GHC.
+findEquivalentModule :: Module -> RnM (Maybe Module)
+findEquivalentModule mod = do
+  liftIO $ putStrLn ("Looking for equivalent to: " ++ unitIdStr)
+  case parseUnitId' unitIdStr of
+    Nothing -> return Nothing
+    Just (pkg, ver, _mhash) -> do
+      muid <- lookFor pkg ver
+      maybe (pure Nothing) (\uid -> return $ Just (mod { moduleUnitId = uid })) muid
+
+  where unitIdStr = unitIdString (moduleUnitId mod)
+
+lookFor :: String -> String -> RnM (Maybe UnitId)
+lookFor pkg ver = do
+  dflags <- getDynFlags
+  let pkgid = mkFastString (pkg ++ "-" ++ ver)
+      pkgs = searchPackageId dflags (SourcePackageId pkgid)
+  liftIO $ putStrLn ("Looking for: " ++ pkg ++ "-" ++ ver)
+  liftIO . putStrLn . unwords $
+    [ "Found", show (length pkgs), "pkgs:" ] ++
+    [ unitIdString (packageConfigId p) | p <- pkgs ]
+  if null pkgs then pure Nothing else pure (Just $ packageConfigId (head pkgs))
diff --git a/compiler/hsSyn/HsExprBin_Instances.hs b/compiler/hsSyn/HsExprBin_Instances.hs
new file mode 100644
index 0000000000..24abf8d69a
--- /dev/null
+++ b/compiler/hsSyn/HsExprBin_Instances.hs
@@ -0,0 +1,1665 @@
+-- too noisy during development...
+{-# OPTIONS_GHC -fno-warn-orphans #-}
+{-# LANGUAGE GeneralizedNewtypeDeriving #-}
+{-# LANGUAGE StandaloneDeriving #-}
+{-# LANGUAGE FlexibleContexts, FlexibleInstances #-}
+module HsExprBin_Instances where
+
+import Control.Applicative
+import Control.Monad
+
+import BasicTypes
+import Binary
+import CoreSyn ( Tickish(..) )
+import GhcPrelude
+import HsBinds
+import HsDecls
+import HsExpr
+import HsExtension
+import HsLit
+import HsPat
+import HsTypes
+import Name
+import Outputable
+import RdrName
+import SeName
+import SrcLoc
+import TcEvidence (HsWrapper(WpHole))
+
+-- * Utilities
+
+putPanic :: String -> String -> a
+putPanic tyName conName =
+  panic ("Binary " ++ tyName ++ ".put: " ++ conName ++ " not supported")
+
+getPanic :: String -> a
+getPanic tyName =
+  panic ("Binary " ++ tyName ++ ".get: unknown (or unsupported) tag")
+
+-- * Binary instances
+
+instance Binary (HsExpr GhcSe) where
+  put_ bh e = case e of
+    HsVar a b ->
+      putByte bh 0 >> put_ bh a >> put_ bh b
+    HsUnboundVar a b ->
+      putByte bh 1 >> put_ bh a >> put_ bh b
+    HsRecFld a b ->
+      putByte bh 2 >> put_ bh a >> put_ bh b
+    HsOverLabel a b c ->
+      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsIPVar a b ->
+      putByte bh 4 >> put_ bh a >> put_ bh b
+    HsOverLit a b ->
+      putByte bh 5 >> put_ bh a >> put_ bh b
+    HsLit a b ->
+      putByte bh 6 >> put_ bh a >> put_ bh b
+    HsLam a b ->
+      putByte bh 7 >> put_ bh a >> put_ bh b
+    HsLamCase a b ->
+      putByte bh 8 >> put_ bh a >> put_ bh b
+    HsApp a b c ->
+      putByte bh 9 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsAppType a b ->
+      putByte bh 10 >> put_ bh a >> put_ bh b
+    OpApp a b c d ->
+      putByte bh 11 >> put_ bh a >> put_ bh b >> put_ bh c
+                    >> put_ bh d
+    NegApp a b c ->
+      putByte bh 12 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsPar a b ->
+      putByte bh 13 >> put_ bh a >> put_ bh b
+    SectionL a b c ->
+      putByte bh 14 >> put_ bh a >> put_ bh b >> put_ bh c
+    SectionR a b c ->
+      putByte bh 15 >> put_ bh a >> put_ bh b >> put_ bh c
+    ExplicitTuple a b c ->
+      putByte bh 16 >> put_ bh a >> put_ bh b >> put_ bh c
+    ExplicitSum a b c d ->
+      putByte bh 17 >> put_ bh a >> put_ bh b >> put_ bh c
+                    >> put_ bh d
+    HsCase a b c ->
+      putByte bh 18 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsIf a b c d e ->
+      putByte bh 19 >> put_ bh a >> put_ bh b >> put_ bh c
+                    >> put_ bh d >> put_ bh e
+    HsMultiIf a b ->
+      putByte bh 20 >> put_ bh a >> put_ bh b
+    HsLet a b c ->
+      putByte bh 21 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsDo a b c ->
+      putByte bh 22 >> put_ bh a >> put_ bh b >> put_ bh c
+    ExplicitList a b c ->
+      putByte bh 23 >> put_ bh a >> put_ bh b >> put_ bh c
+    RecordCon a b c ->
+      putByte bh 24 >> put_ bh a >> put_ bh b >> put_ bh c
+    RecordUpd a b c ->
+      putByte bh 25 >> put_ bh a >> put_ bh b >> put_ bh c
+    ExprWithTySig a b ->
+      putByte bh 26 >> put_ bh a >> put_ bh b
+    ArithSeq a b c ->
+      putByte bh 27 >> put_ bh a >> put_ bh b >> put_ bh c
+    EWildPat a ->
+      putByte bh 28 >> put_ bh a
+    EAsPat a b c ->
+      putByte bh 29 >> put_ bh a >> put_ bh b >> put_ bh c
+    EViewPat a b c ->
+      putByte bh 30 >> put_ bh a >> put_ bh b >> put_ bh c
+    ELazyPat a b ->
+      putByte bh 31 >> put_ bh a >> put_ bh b
+    HsStatic a b ->
+      putByte bh 32 >> put_ bh a >> put_ bh b
+    HsProc a b c ->
+      putByte bh 33 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsBinTick a b c d ->
+      putByte bh 34 >> put_ bh a >> put_ bh b >> put_ bh c
+                    >> put_ bh d
+    HsTickPragma a b c d e ->
+      putByte bh 35 >> put_ bh a >> put_ bh b >> put_ bh c
+                    >> put_ bh d >> put_ bh e
+    HsSpliceE a b ->
+      putByte bh 36 >> put_ bh a >> put_ bh b
+    HsSCC a b c d ->
+      putByte bh 37 >> put_ bh a >> put_ bh b >> put_ bh c
+                    >> put_ bh d
+    HsCoreAnn a b c d ->
+      putByte bh 38 >> put_ bh a >> put_ bh b >> put_ bh c
+                    >> put_ bh d
+    HsBracket a b ->
+      putByte bh 39 >> put_ bh a >> put_ bh b
+    XExpr a ->
+      putByte bh 40 >> put_ bh a
+    HsConLikeOut {} -> putPanic "HsExpr" "HsConLikeOut"
+    HsRnBracketOut {} -> putPanic "HsExpr" "HsRnBracketOut"
+    HsTcBracketOut {} -> putPanic "HsExpr" "HsTcBracketOut"
+    HsArrApp {} -> putPanic "HsExpr" "HsArrApp"
+    HsArrForm {} -> putPanic "HsExpr" "HsArrForm"
+    HsTick {} -> putPanic "HsExpr" "HsTick"
+    HsWrap {} -> putPanic "HsExpr" "HsWrap"
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0  -> HsVar <$> get bh <*> get bh
+      1  -> HsUnboundVar <$> get bh <*> get bh
+      2  -> HsRecFld <$> get bh <*> get bh
+      3  -> HsOverLabel <$> get bh <*> get bh <*> get bh
+      4  -> HsIPVar <$> get bh <*> get bh
+      5  -> HsOverLit <$> get bh <*> get bh
+      6  -> HsLit <$> get bh <*> get bh
+      7  -> HsLam <$> get bh <*> get bh
+      8  -> HsLamCase <$> get bh <*> get bh
+      9  -> HsApp <$> get bh <*> get bh <*> get bh
+      10 -> HsAppType <$> get bh <*> get bh
+      11 -> OpApp <$> get bh <*> get bh <*> get bh <*> get bh
+      12 -> NegApp <$> get bh <*> get bh <*> get bh
+      13 -> HsPar <$> get bh <*> get bh
+      14 -> SectionL <$> get bh <*> get bh <*> get bh
+      15 -> SectionR <$> get bh <*> get bh <*> get bh
+      16 -> ExplicitTuple <$> get bh <*> get bh <*> get bh
+      17 -> ExplicitSum <$> get bh <*> get bh <*> get bh <*> get bh
+      18 -> HsCase <$> get bh <*> get bh <*> get bh
+      19 -> HsIf <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+      20 -> HsMultiIf <$> get bh <*> get bh
+      21 -> HsLet <$> get bh <*> get bh <*> get bh
+      22 -> HsDo <$> get bh <*> get bh <*> get bh
+      23 -> ExplicitList <$> get bh <*> get bh <*> get bh
+      24 -> RecordCon <$> get bh <*> get bh <*> get bh
+      25 -> RecordUpd <$> get bh <*> get bh <*> get bh
+      26 -> ExprWithTySig <$> get bh <*> get bh
+      27 -> ArithSeq <$> get bh <*> get bh <*> get bh
+      28 -> EWildPat <$> get bh
+      29 -> EAsPat <$> get bh <*> get bh <*> get bh
+      30 -> EViewPat <$> get bh <*> get bh <*> get bh
+      31 -> ELazyPat <$> get bh <*> get bh
+      32 -> HsStatic <$> get bh <*> get bh
+      33 -> HsProc <$> get bh <*> get bh <*> get bh
+      34 -> HsBinTick <$> get bh <*> get bh <*> get bh <*> get bh
+      35 -> HsTickPragma <$> get bh <*> get bh <*> get bh
+                         <*> get bh <*> get bh
+      36 -> HsSpliceE <$> get bh <*> get bh
+      37 -> HsSCC <$> get bh <*> get bh <*> get bh <*> get bh
+      38 -> HsCoreAnn <$> get bh <*> get bh <*> get bh <*> get bh
+      39 -> HsBracket <$> get bh <*> get bh
+      40 -> XExpr <$> get bh
+      _  -> getPanic "HsExpr"
+
+instance Binary (HsBracket GhcSe) where
+  put_ bh b = case b of
+    ExpBr a b ->
+      putByte bh 0 >> put_ bh a >> put_ bh b
+    PatBr a b ->
+      putByte bh 1 >> put_ bh a >> put_ bh b
+    DecBrL a b ->
+      putByte bh 2 >> put_ bh a >> put_ bh b
+    DecBrG a b ->
+      putByte bh 3 >> put_ bh a >> put_ bh b
+    TypBr a b ->
+      putByte bh 4 >> put_ bh a >> put_ bh b
+    VarBr a b c ->
+      putByte bh 5 >> put_ bh a >> put_ bh b >> put_ bh c
+    TExpBr a b ->
+      putByte bh 6 >> put_ bh a >> put_ bh b
+    XBracket a ->
+      putByte bh 7 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ExpBr <$> get bh <*> get bh
+      1 -> PatBr <$> get bh <*> get bh
+      2 -> DecBrL <$> get bh <*> get bh
+      3 -> DecBrG <$> get bh <*> get bh
+      4 -> TypBr <$> get bh <*> get bh
+      5 -> VarBr <$> get bh <*> get bh <*> get bh
+      6 -> TExpBr <$> get bh <*> get bh
+      7 -> XBracket <$> get bh
+      _ -> getPanic "HsBracket"
+
+instance Binary SeName where
+  put_ bh (SeName n) = put_ bh n
+  get bh = mkSeName <$> get bh
+
+instance Binary UnboundVar where
+  put_ bh v = case v of
+    OutOfScope a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    TrueExprHole a -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> OutOfScope <$> get bh <*> get bh
+      1 -> TrueExprHole <$> get bh
+      _ -> getPanic "UnboundVar"
+
+instance Binary a => Binary (StmtLR GhcSe GhcSe a) where
+  put_ bh s = case s of
+    LastStmt a b c d ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    BindStmt a b c d e ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                   >> put_ bh e
+    ApplicativeStmt a b c ->
+      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c
+    BodyStmt a b c d ->
+      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    LetStmt a b ->
+      putByte bh 4 >> put_ bh a >> put_ bh b
+    ParStmt a b c d ->
+      putByte bh 5 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    RecStmt a b c d e f g ->
+      putByte bh 6 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                   >> put_ bh e >> put_ bh f >> put_ bh g
+    TransStmt a b c d e f g h i ->
+      putByte bh 7 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                   >> put_ bh e >> put_ bh f >> put_ bh g >> put_ bh h
+                   >> put_ bh i
+    XStmtLR a ->
+      putByte bh 8 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> LastStmt <$> get bh <*> get bh <*> get bh <*> get bh
+      1 -> BindStmt <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+      2 -> ApplicativeStmt <$> get bh <*> get bh <*> get bh
+      3 -> BodyStmt <$> get bh <*> get bh <*> get bh <*> get bh
+      4 -> LetStmt <$> get bh <*> get bh
+      5 -> ParStmt <$> get bh <*> get bh <*> get bh <*> get bh
+      6 -> RecStmt <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+                   <*> get bh <*> get bh
+      7 -> TransStmt <$> get bh <*> get bh <*> get bh <*> get bh
+                     <*> get bh <*> get bh <*> get bh <*> get bh
+                     <*> get bh
+      8 -> XStmtLR <$> get bh
+      _ -> getPanic "StmtLR"
+
+instance Binary (HsGroup GhcSe) where
+  put_ bh x = case x of
+    HsGroup a b c d e f g h i j k l ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                   >> put_ bh e >> put_ bh f >> put_ bh g >> put_ bh h
+                   >> put_ bh i >> put_ bh j >> put_ bh k >> put_ bh l
+    XHsGroup a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsGroup <$> get bh <*> get bh <*> get bh <*> get bh
+                   <*> get bh <*> get bh <*> get bh <*> get bh
+                   <*> get bh <*> get bh <*> get bh <*> get bh
+      1 -> XHsGroup <$> get bh
+      _ -> getPanic "HsGroup"
+
+instance Binary (TyClGroup GhcSe) where
+  put_ bh g = case g of
+    TyClGroup a b c d ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    XTyClGroup a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> TyClGroup <$> get bh <*> get bh <*> get bh <*> get bh
+      1 -> XTyClGroup <$> get bh
+      _ -> getPanic "TyClGroup"
+
+instance Binary (HsCmdTop GhcSe) where
+  put_ bh c = case c of
+    HsCmdTop a b ->
+      putByte bh 0 >> put_ bh a >> put_ bh b
+    XCmdTop a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsCmdTop <$> get bh <*> get bh
+      1 -> XCmdTop <$> get bh
+      _ -> getPanic "HsCmdTop"
+
+instance Binary (HsCmd GhcSe) where
+  put_ bh c = case c of
+    HsCmdArrApp a b c d e ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d >> put_ bh e
+    HsCmdArrForm a b c d e ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d >> put_ bh e
+    HsCmdApp a b c ->
+      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsCmdLam a b ->
+      putByte bh 3 >> put_ bh a >> put_ bh b
+    HsCmdPar a b ->
+      putByte bh 4 >> put_ bh a >> put_ bh b
+    HsCmdCase a b c ->
+      putByte bh 5 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsCmdIf a b c d e ->
+      putByte bh 6 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d >> put_ bh e
+    HsCmdLet a b c ->
+      putByte bh 7 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsCmdDo a b ->
+      putByte bh 8 >> put_ bh a >> put_ bh b
+    XCmd a ->
+      putByte bh 9 >> put_ bh a
+    HsCmdWrap {} ->
+      putPanic "HsCmdWrap" "HsCmd"
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsCmdArrApp <$> get bh <*> get bh <*> get bh
+                       <*> get bh <*> get bh
+      1 -> HsCmdArrForm <$> get bh <*> get bh <*> get bh
+                        <*> get bh <*> get bh
+      2 -> HsCmdApp <$> get bh <*> get bh <*> get bh
+      3 -> HsCmdLam <$> get bh <*> get bh
+      4 -> HsCmdPar <$> get bh <*> get bh
+      5 -> HsCmdCase <$> get bh <*> get bh <*> get bh
+      6 -> HsCmdIf <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+      7 -> HsCmdLet <$> get bh <*> get bh <*> get bh
+      8 -> HsCmdDo <$> get bh <*> get bh
+      9 -> XCmd <$> get bh
+      _ -> getPanic "HsCmd"
+
+instance Binary HsArrAppType where
+  put_ bh t = putByte bh $ case t of
+    HsHigherOrderApp -> 0
+    HsFirstOrderApp  -> 1
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure HsHigherOrderApp
+      1 -> pure HsFirstOrderApp
+      _ -> getPanic "HsArrAppType"
+
+instance Binary TransForm where
+  put_ bh f = putByte bh $ case f of
+    ThenForm  -> 0
+    GroupForm -> 1
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure ThenForm
+      1 -> pure GroupForm
+      _ -> getPanic "TransForm"
+
+instance Binary (ApplicativeArg GhcSe) where
+  put_ bh a = case a of
+    ApplicativeArgOne a b c d ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    ApplicativeArgMany a b c d ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    XApplicativeArg a ->
+      putByte bh 2 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ApplicativeArgOne <$> get bh <*> get bh <*> get bh <*> get bh
+      1 -> ApplicativeArgMany <$> get bh <*> get bh <*> get bh <*> get bh
+      2 -> XApplicativeArg <$> get bh
+      _ -> getPanic "ApplicativeArg"
+
+instance Binary (ParStmtBlock GhcSe GhcSe) where
+  put_ bh b = case b of
+    ParStmtBlock a b c d ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    XParStmtBlock a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ParStmtBlock <$> get bh <*> get bh <*> get bh <*> get bh
+      1 -> XParStmtBlock <$> get bh
+      _ -> getPanic "ParStmtBlock"
+
+instance Binary (SyntaxExpr GhcSe) where
+  put_ bh (SyntaxExpr a [] WpHole) = put_ bh a
+  put_ _ _ = panic "Binary SyntaxExpr.put: wrappers should be empty"
+  get bh = SyntaxExpr <$> get bh <*> pure [] <*> pure WpHole
+
+instance Binary a => Binary (GRHSs GhcSe a) where
+  put_ bh g = case g of
+    GRHSs a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XGRHSs a -> putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> GRHSs <$> get bh <*> get bh <*> get bh
+      1 -> XGRHSs <$> get bh
+      _ -> getPanic "GRHSs"
+
+instance Binary a => Binary (GRHS GhcSe a) where
+  put_ bh g = case g of
+    GRHS a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XGRHS a -> putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> GRHS <$> get bh <*> get bh <*> get bh
+      1 -> XGRHS <$> get bh
+      _ -> getPanic "GRHS"
+
+instance Binary a => Binary (MatchGroup GhcSe a) where
+  put_ bh g = case g of
+    MG a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XMatchGroup a -> putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> MG <$> get bh <*> get bh <*> get bh
+      1 -> XMatchGroup <$> get bh
+      _ -> getPanic "MatchGroup"
+
+instance Binary a => Binary (Match GhcSe a) where
+  put_ bh m = case m of
+    Match a b c d ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    XMatch a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> Match <$> get bh <*> get bh <*> get bh <*> get bh
+      1 -> XMatch <$> get bh
+      _ -> getPanic "Match"
+
+instance Binary (HsMatchContext SeName) where
+  put_ bh c = case c of
+    FunRhs a b c ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    LambdaExpr ->
+      putByte bh 1
+    CaseAlt ->
+      putByte bh 2
+    IfAlt ->
+      putByte bh 3
+    ProcExpr ->
+      putByte bh 4
+    PatBindRhs ->
+      putByte bh 5
+    RecUpd ->
+      putByte bh 6
+    StmtCtxt a ->
+      putByte bh 7 >> put_ bh a
+    ThPatSplice ->
+      putByte bh 8
+    ThPatQuote ->
+      putByte bh 9
+    PatSyn ->
+      putByte bh 10
+    PatBindGuards ->
+      putByte bh 11
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0  -> FunRhs <$> get bh <*> get bh <*> get bh
+      1  -> pure LambdaExpr
+      2  -> pure CaseAlt
+      3  -> pure IfAlt
+      4  -> pure ProcExpr
+      5  -> pure PatBindRhs
+      6  -> pure RecUpd
+      7  -> StmtCtxt <$> get bh
+      8  -> pure ThPatSplice
+      9  -> pure ThPatQuote
+      10 -> pure PatSyn
+      11 -> pure PatBindGuards
+      _  -> getPanic "HsMatchContext"
+
+instance Binary (HsStmtContext SeName) where
+  put_ bh c = case c of
+    ListComp        -> putByte bh 0
+    MonadComp       -> putByte bh 1
+    DoExpr          -> putByte bh 3
+    MDoExpr         -> putByte bh 4
+    ArrowExpr       -> putByte bh 5
+    GhciStmtCtxt    -> putByte bh 6
+    PatGuard a      -> putByte bh 7 >> put_ bh a
+    ParStmtCtxt a   -> putByte bh 8 >> put_ bh a
+    TransStmtCtxt a -> putByte bh 9 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure ListComp
+      1 -> pure MonadComp
+      3 -> pure DoExpr
+      4 -> pure MDoExpr
+      5 -> pure ArrowExpr
+      6 -> pure GhciStmtCtxt
+      7 -> PatGuard <$> get bh
+      8 -> ParStmtCtxt <$> get bh
+      9 -> TransStmtCtxt <$> get bh
+      _ -> getPanic "HsStmtContext"
+
+instance Binary (ArithSeqInfo GhcSe) where
+  put_ bh i = case i of
+    From a ->
+      putByte bh 0 >> put_ bh a
+    FromThen a b ->
+      putByte bh 1 >> put_ bh a >> put_ bh b
+    FromTo a b ->
+      putByte bh 2 >> put_ bh a >> put_ bh b
+    FromThenTo a b c ->
+      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> From <$> get bh
+      1 -> FromThen <$> get bh <*> get bh
+      2 -> FromTo <$> get bh <*> get bh
+      3 -> FromThenTo <$> get bh <*> get bh <*> get bh
+      _ -> getPanic "ArithSeqInfo"
+
+instance Binary (HsTupArg GhcSe) where
+  put_ bh a = case a of
+    Present a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    Missing a -> putByte bh 1 >> put_ bh a
+    XTupArg a -> putByte bh 2 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> Present <$> get bh <*> get bh
+      1 -> Missing <$> get bh
+      2 -> XTupArg <$> get bh
+      _ -> getPanic "HsTupArg"
+
+instance Binary (Pat GhcSe) where
+  put_ bh p = case p of
+    WildPat a ->
+      putByte bh 0 >> put_ bh a
+    VarPat a b ->
+      putByte bh 1 >> put_ bh a >> put_ bh b
+    LazyPat a b ->
+      putByte bh 2 >> put_ bh a >> put_ bh b
+    AsPat a b c ->
+      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c
+    ParPat a b ->
+      putByte bh 4 >> put_ bh a >> put_ bh b
+    BangPat a b ->
+      putByte bh 5 >> put_ bh a >> put_ bh b
+    ListPat a b ->
+      putByte bh 6 >> put_ bh a >> put_ bh b
+    TuplePat a b c ->
+      putByte bh 7 >> put_ bh a >> put_ bh b >> put_ bh c
+    SumPat a b c d ->
+      putByte bh 8 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    ConPatIn a b ->
+      putByte bh 9 >> put_ bh a >> put_ bh b
+    ViewPat a b c ->
+      putByte bh 10 >> put_ bh a >> put_ bh b >> put_ bh c
+    LitPat a b ->
+      putByte bh 11 >> put_ bh a >> put_ bh b
+    NPat a b c d ->
+      putByte bh 12 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    NPlusKPat a b c d e f ->
+      putByte bh 13 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                    >> put_ bh e >> put_ bh f
+    SigPat a b ->
+      putByte bh 14 >> put_ bh a >> put_ bh b
+    SplicePat a b ->
+      putByte bh 15 >> put_ bh a >> put_ bh b
+    XPat a ->
+      putByte bh 16 >> put_ bh a
+    ConPatOut {} -> putPanic "Pat" "ConPatOut"
+    CoPat {} -> putPanic "Pat" "CoPat"
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> WildPat <$> get bh
+      1 -> VarPat <$> get bh <*> get bh
+      2 -> LazyPat <$> get bh <*> get bh
+      3 -> AsPat <$> get bh <*> get bh <*> get bh
+      4 -> ParPat <$> get bh <*> get bh
+      5 -> BangPat <$> get bh <*> get bh
+      6 -> ListPat <$> get bh <*> get bh
+      7 -> TuplePat <$> get bh <*> get bh <*> get bh
+      8 -> SumPat <$> get bh <*> get bh <*> get bh <*> get bh
+      9 -> ConPatIn <$> get bh <*> get bh
+      10 -> ViewPat <$> get bh <*> get bh <*> get bh
+      11 -> LitPat <$> get bh <*> get bh
+      12 -> NPat <$> get bh <*> get bh <*> get bh <*> get bh
+      13 -> NPlusKPat <$> get bh <*> get bh <*> get bh <*> get bh
+                      <*> get bh <*> get bh
+      14 -> SigPat <$> get bh <*> get bh
+      15 -> SplicePat <$> get bh <*> get bh
+      16 -> XPat <$> get bh
+      _ -> getPanic "HsPat"
+
+instance Binary NoExt where
+  put_ _ NoExt = return ()
+  get _ = pure NoExt
+
+instance (Binary (FieldOcc a), Binary b) => Binary (HsRecFields a b) where
+  put_ bh (HsRecFields a b) = put_ bh a >> put_ bh b
+  get bh = HsRecFields <$> get bh <*> get bh
+
+instance (Binary id, Binary arg) => Binary (HsRecField' id arg) where
+  put_ bh (HsRecField a b c) = put_ bh a >> put_ bh b >> put_ bh c
+  get bh = HsRecField <$> get bh <*> get bh <*> get bh
+
+instance Binary (HsType GhcSe) where
+  put_ bh t = case t of
+    HsForAllTy a b c ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsQualTy a b c ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsTyVar a b c ->
+      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsAppTy a b c ->
+      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsFunTy a b c ->
+      putByte bh 4 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsListTy a b ->
+      putByte bh 5 >> put_ bh a >> put_ bh b
+    HsTupleTy a b c ->
+      putByte bh 6 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsSumTy a b ->
+      putByte bh 7 >> put_ bh a >> put_ bh b
+    HsOpTy a b c d ->
+      putByte bh 8 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    HsParTy a b ->
+      putByte bh 9 >> put_ bh a >> put_ bh b
+    HsIParamTy a b c ->
+      putByte bh 10 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsKindSig a b c ->
+      putByte bh 11 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsBangTy a b c ->
+      putByte bh 12 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsRecTy a b ->
+      putByte bh 13 >> put_ bh a >> put_ bh b
+    HsExplicitListTy a b c ->
+      putByte bh 14 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsExplicitTupleTy a b ->
+      putByte bh 15 >> put_ bh a >> put_ bh b
+    HsTyLit a b ->
+      putByte bh 16 >> put_ bh a >> put_ bh b
+    HsWildCardTy a ->
+      putByte bh 17 >> put_ bh a
+    HsDocTy a b c ->
+      putByte bh 18 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsSpliceTy a b ->
+      putByte bh 19 >> put_ bh a >> put_ bh b
+    HsStarTy a b ->
+      putByte bh 20 >> put_ bh a >> put_ bh b
+    XHsType _ ->
+      putPanic "XHsType" "HsType"
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsForAllTy <$> get bh <*> get bh <*> get bh
+      1 -> HsQualTy <$> get bh <*> get bh <*> get bh
+      2 -> HsTyVar <$> get bh <*> get bh <*> get bh
+      3 -> HsAppTy <$> get bh <*> get bh <*> get bh
+      4 -> HsFunTy <$> get bh <*> get bh <*> get bh
+      5 -> HsListTy <$> get bh <*> get bh
+      6 -> HsTupleTy <$> get bh <*> get bh <*> get bh
+      7 -> HsSumTy <$> get bh <*> get bh
+      8 -> HsOpTy <$> get bh <*> get bh <*> get bh <*> get bh
+      9 -> HsParTy <$> get bh <*> get bh
+      10 -> HsIParamTy <$> get bh <*> get bh <*> get bh
+      11 -> HsKindSig <$> get bh <*> get bh <*> get bh
+      12 -> HsBangTy <$> get bh <*> get bh <*> get bh
+      13 -> HsRecTy <$> get bh <*> get bh
+      14 -> HsExplicitListTy <$> get bh <*> get bh <*> get bh
+      15 -> HsExplicitTupleTy <$> get bh <*> get bh
+      16 -> HsTyLit <$> get bh <*> get bh
+      17 -> HsWildCardTy <$> get bh
+      18 -> HsDocTy <$> get bh <*> get bh <*> get bh
+      19 -> HsSpliceTy <$> get bh <*> get bh
+      20 -> HsStarTy <$> get bh <*> get bh
+      _  -> getPanic "HsType"
+
+instance Binary HsTyLit where
+  put_ bh l = case l of
+    HsNumTy a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    HsStrTy a b -> putByte bh 1 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsNumTy <$> get bh <*> get bh
+      1 -> HsStrTy <$> get bh <*> get bh
+      _ -> getPanic "HsTyLit"
+
+instance Binary a => Binary (HsWildCardBndrs GhcSe a) where
+  put_ bh w = case w of
+    HsWC a b ->
+      putByte bh 0 >> put_ bh a >> put_ bh b
+    XHsWildCardBndrs a ->
+      putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsWC <$> get bh <*> get bh
+      1 -> XHsWildCardBndrs <$> get bh
+      _ -> getPanic "HsWildCardBndrs"
+
+instance Binary a => Binary (HsImplicitBndrs GhcSe a) where
+  put_ bh b = case b of
+    HsIB a b ->
+      putByte bh 0 >> put_ bh a >> put_ bh b
+    XHsImplicitBndrs a ->
+      putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsIB <$> get bh <*> get bh
+      1 -> XHsImplicitBndrs <$> get bh
+      _ -> getPanic "HsImplicitBndrs"
+
+instance Binary HsTupleSort where
+  put_ bh s = putByte bh (case s of
+    HsUnboxedTuple -> 0
+    HsBoxedTuple -> 1
+    HsConstraintTuple -> 2
+    HsBoxedOrConstraintTuple -> 3)
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure HsUnboxedTuple
+      1 -> pure HsBoxedTuple
+      2 -> pure HsConstraintTuple
+      3 -> pure HsBoxedOrConstraintTuple
+      _ -> getPanic "HsTupleSort"
+
+instance Binary (ConDeclField GhcSe) where
+  put_ bh f = case f of
+    ConDeclField a b c d ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    XConDeclField a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ConDeclField <$> get bh <*> get bh <*> get bh <*> get bh
+      1 -> XConDeclField <$> get bh
+      _ -> getPanic "ConDeclField"
+
+instance Binary (FieldOcc GhcSe) where
+  put_ bh o = case o of
+    FieldOcc a b ->
+      putByte bh 0 >> put_ bh a >> put_ bh b
+    XFieldOcc a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> FieldOcc <$> get bh <*> get bh
+      1 -> XFieldOcc <$> get bh
+      _ -> getPanic "FieldOcc"
+
+instance Binary (HsTyVarBndr GhcSe) where
+  put_ bh v = case v of
+    UserTyVar a b ->
+      putByte bh 0 >> put_ bh a >> put_ bh b
+    KindedTyVar a b c ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+    XTyVarBndr a ->
+      putByte bh 2 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> UserTyVar <$> get bh <*> get bh
+      1 -> KindedTyVar <$> get bh <*> get bh <*> get bh
+      2 -> XTyVarBndr <$> get bh
+      _ -> getPanic "HsTyVarBndr"
+
+instance (Binary a, Binary b) => Binary (HsConDetails a b) where
+  put_ bh c = case c of
+    PrefixCon a -> putByte bh 0 >> put_ bh a
+    RecCon a -> putByte bh 1 >> put_ bh a
+    InfixCon a b -> putByte bh 2 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> PrefixCon <$> get bh
+      1 -> RecCon <$> get bh
+      2 -> InfixCon <$> get bh <*> get bh
+      _ -> getPanic "HsConDetails"
+
+instance Binary (AmbiguousFieldOcc GhcSe) where
+  put_ bh o = case o of
+    Unambiguous a b ->
+      putByte bh 0 >> put_ bh a >> put_ bh b
+    Ambiguous a b ->
+      putByte bh 1 >> put_ bh a >> put_ bh b
+    XAmbiguousFieldOcc a ->
+      putByte bh 2 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> Unambiguous <$> get bh <*> get bh
+      1 -> Ambiguous <$> get bh <*> get bh
+      2 -> XAmbiguousFieldOcc <$> get bh
+      _ -> getPanic "AmbiguousOccField"
+
+instance Binary (LHsQTyVars GhcSe) where
+  put_ bh v = case v of
+    HsQTvs a b ->
+      putByte bh 0 >> put_ bh a >> put_ bh b
+    XLHsQTyVars a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsQTvs <$> get bh <*> get bh
+      1 -> XLHsQTyVars <$> get bh
+      _ -> getPanic "LHsQTyVars"
+
+instance Binary (Sig GhcSe) where
+  put_ bh s = case s of
+    TypeSig a b c ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    PatSynSig a b c ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+    ClassOpSig a b c d ->
+      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    IdSig a b ->
+      putByte bh 3 >> put_ bh a >> put_ bh b
+    FixSig a b ->
+      putByte bh 4 >> put_ bh a >> put_ bh b
+    InlineSig a b c ->
+      putByte bh 5 >> put_ bh a >> put_ bh b >> put_ bh c
+    SpecSig a b c d ->
+      putByte bh 6 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    SpecInstSig a b c ->
+      putByte bh 7 >> put_ bh a >> put_ bh b >> put_ bh c
+    SCCFunSig a b c d ->
+      putByte bh 8 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    CompleteMatchSig a b c d ->
+      putByte bh 9 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    MinimalSig a b c ->
+      putByte bh 10 >> put_ bh a >> put_ bh b >> put_ bh c
+    XSig a ->
+      putByte bh 11 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> TypeSig <$> get bh <*> get bh <*> get bh
+      1 -> PatSynSig <$> get bh <*> get bh <*> get bh
+      2 -> ClassOpSig <$> get bh <*> get bh <*> get bh <*> get bh
+      3 -> IdSig <$> get bh <*> get bh
+      4 -> FixSig <$> get bh <*> get bh
+      5 -> InlineSig <$> get bh <*> get bh <*> get bh
+      6 -> SpecSig <$> get bh <*> get bh <*> get bh <*> get bh
+      7 -> SpecInstSig <$> get bh <*> get bh <*> get bh
+      8 -> SCCFunSig <$> get bh <*> get bh <*> get bh <*> get bh
+      9 -> CompleteMatchSig <$> get bh <*> get bh <*> get bh <*> get bh
+      10 -> MinimalSig <$> get bh <*> get bh <*> get bh
+      11 -> XSig <$> get bh
+      _ -> getPanic "Sig"
+
+instance Binary (FixitySig GhcSe) where
+  put_ bh s = case s of
+    FixitySig a b c ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XFixitySig a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> FixitySig <$> get bh <*> get bh <*> get bh
+      1 -> XFixitySig <$> get bh
+      _ -> getPanic "FixitySig"
+
+instance Binary (HsBindLR GhcSe GhcSe) where
+  put_ bh b = case b of
+    -- TODO: we drop the "fun_co_fn" field, as it seems
+    --       to always be WpHole in the places where the binary
+    --       serialisation instances will be used.
+    -- TODO: we drop the "fun_tick" field, as it is unlikely
+    --       to be used in our immediate use cases. Let's
+    --       return to parametrising away the 'Id' in that
+    --       field's type.
+    FunBind a b c d _ -> case d of
+      WpHole ->
+        putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+      _ ->
+        panic "Binary HsBindLR: FunBind with non-WpHole value in fun_co_fn"
+    -- TODO: same as for FunBind, we drop pat_ticks
+    PatBind a b c _ ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+    VarBind a b c d ->
+      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    PatSynBind a b ->
+      putByte bh 3 >> put_ bh a >> put_ bh b
+    XHsBindsLR a ->
+      putByte bh 4 >> put_ bh a
+    AbsBinds {} -> putPanic "HsBindsLR" "AbsBinds"
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> FunBind <$> get bh <*> get bh <*> get bh <*> pure WpHole <*> pure []
+      1 -> PatBind <$> get bh <*> get bh <*> get bh <*> pure ([], [])
+      2 -> VarBind <$> get bh <*> get bh <*> get bh <*> get bh
+      3 -> PatSynBind <$> get bh <*> get bh
+      4 -> XHsBindsLR <$> get bh
+      _ -> getPanic "HsBindsLR"
+
+instance Binary (HsLocalBindsLR GhcSe GhcSe) where
+  put_ bh b = case b of
+    HsValBinds a b    -> putByte bh 0 >> put_ bh a >> put_ bh b
+    EmptyLocalBinds a -> putByte bh 1 >> put_ bh a
+    XHsLocalBindsLR a -> putByte bh 2 >> put_ bh a
+    HsIPBinds {}      -> putPanic "HsLocalBindsLR" "HsIPBinds"
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsValBinds <$> get bh <*> get bh
+      1 -> EmptyLocalBinds <$> get bh
+      2 -> XHsLocalBindsLR <$> get bh
+      _ -> getPanic "HsLocalBindsLR"
+
+instance Binary (HsValBindsLR GhcSe GhcSe) where
+  put_ bh b = case b of
+    ValBinds a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XValBindsLR {} -> putPanic "HsValBindsLR" "ValBindsOut"
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ValBinds <$> get bh <*> get bh <*> get bh
+      _ -> getPanic "HsValBindsLR"
+
+instance Binary (PatSynBind GhcSe GhcSe) where
+  put_ bh b = case b of
+    PSB a b c d e ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                   >> put_ bh e
+    XPatSynBind a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> PSB <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+      1 -> XPatSynBind <$> get bh
+      _ -> getPanic "PatSynBind"
+
+instance Binary (HsPatSynDir GhcSe) where
+  put_ bh d = case d of
+    Unidirectional -> putByte bh 0
+    ImplicitBidirectional -> putByte bh 1
+    ExplicitBidirectional a -> putByte bh 2 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure Unidirectional
+      1 -> pure ImplicitBidirectional
+      2 -> ExplicitBidirectional <$> get bh
+      _ -> getPanic "HsPatSynDir"
+
+instance Binary a => Binary (RecordPatSynField a) where
+  put_ bh (RecordPatSynField a b) = put_ bh a >> put_ bh b
+  get bh = RecordPatSynField <$> get bh <*> get bh
+
+instance Binary (IPBind GhcSe) where
+  put_ bh i = case i of
+    IPBind a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XIPBind a -> putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> IPBind <$> get bh <*> get bh <*> get bh
+      1 -> XIPBind <$> get bh
+      _ -> getPanic "IPBind"
+
+-- * HsDecls
+
+instance Binary (HsDecl GhcSe) where
+  put_ bh d = case d of
+    TyClD a b      -> putByte bh 0 >> put_ bh a >> put_ bh b
+    InstD a b      -> putByte bh 1 >> put_ bh a >> put_ bh b
+    DerivD a b     -> putByte bh 2 >> put_ bh a >> put_ bh b
+    ValD a b       -> putByte bh 3 >> put_ bh a >> put_ bh b
+    SigD a b       -> putByte bh 4 >> put_ bh a >> put_ bh b
+    DefD a b       -> putByte bh 5 >> put_ bh a >> put_ bh b
+    ForD a b       -> putByte bh 6 >> put_ bh a >> put_ bh b
+    WarningD a b   -> putByte bh 7 >> put_ bh a >> put_ bh b
+    RoleAnnotD a b -> putByte bh 8 >> put_ bh a >> put_ bh b
+    RuleD a b      -> putByte bh 9 >> put_ bh a >> put_ bh b
+    AnnD a b       -> putByte bh 10 >> put_ bh a >> put_ bh b
+    SpliceD a b    -> putByte bh 11 >> put_ bh a >> put_ bh b
+    DocD a b       -> putByte bh 12 >> put_ bh a >> put_ bh b
+    XHsDecl a      -> putByte bh 13 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> TyClD <$> get bh <*> get bh
+      1 -> InstD <$> get bh <*> get bh
+      2 -> DerivD <$> get bh <*> get bh
+      3 -> ValD <$> get bh <*> get bh
+      4 -> SigD <$> get bh <*> get bh
+      5 -> DefD <$> get bh <*> get bh
+      6 -> ForD <$> get bh <*> get bh
+      7 -> WarningD <$> get bh <*> get bh
+      8 -> RoleAnnotD <$> get bh <*> get bh
+      9 -> RuleD <$> get bh <*> get bh
+      10 -> AnnD <$> get bh <*> get bh
+      11 -> SpliceD <$> get bh <*> get bh
+      12 -> DocD <$> get bh <*> get bh
+      13 -> XHsDecl <$> get bh
+      _ -> getPanic "HsDecl"
+
+instance Binary (ForeignDecl GhcSe) where
+  put_ bh d = case d of
+    ForeignImport a b c d ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d
+    ForeignExport a b c d ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d
+    XForeignDecl a ->
+      putByte bh 2 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ForeignImport <$> get bh <*> get bh <*> get bh <*> get bh
+      1 -> ForeignExport <$> get bh <*> get bh <*> get bh <*> get bh
+      2 -> XForeignDecl <$> get bh
+      _ -> getPanic "ForeignDecl"
+
+instance Binary (DefaultDecl GhcSe) where
+  put_ bh d = case d of
+    DefaultDecl a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    XDefaultDecl a -> putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> DefaultDecl <$> get bh <*> get bh
+      1 -> XDefaultDecl <$> get bh
+      _ -> getPanic "DefaultDecl"
+
+instance Binary (TyClDecl GhcSe) where
+  put_ bh d = case d of
+    FamDecl a b ->
+      putByte bh 0 >> put_ bh a >> put_ bh b
+    SynDecl a b c d e ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d >> put_ bh e
+    DataDecl a b c d e ->
+      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d >> put_ bh e
+    ClassDecl a b c d e f g h i j k ->
+      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d >> put_ bh e >> put_ bh f
+                   >> put_ bh g >> put_ bh h >> put_ bh i
+                   >> put_ bh j >> put_ bh k
+    XTyClDecl a ->
+      putByte bh 4 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> FamDecl <$> get bh <*> get bh
+      1 -> SynDecl <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+      2 -> DataDecl <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+      3 -> ClassDecl <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+                     <*> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+                     <*> get bh
+      4 -> XTyClDecl <$> get bh
+      _ -> getPanic "TyClDecl"
+
+instance Binary DocDecl where
+  put_ bh d = case d of
+    DocCommentNext a    -> putByte bh 0 >> put_ bh a
+    DocCommentPrev a    -> putByte bh 1 >> put_ bh a
+    DocCommentNamed a b -> putByte bh 2 >> put_ bh a >> put_ bh b
+    DocGroup a b        -> putByte bh 3 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> DocCommentNext <$> get bh
+      1 -> DocCommentPrev <$> get bh
+      2 -> DocCommentNamed <$> get bh <*> get bh
+      3 -> DocGroup <$> get bh <*> get bh
+      _ -> getPanic "DocDecl"
+
+instance Binary (WarnDecls GhcSe) where
+  put_ bh d = case d of
+    Warnings a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XWarnDecls a   -> putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> Warnings <$> get bh <*> get bh <*> get bh
+      1 -> XWarnDecls <$> get bh
+      _ -> getPanic "WarnDecls"
+
+instance Binary (WarnDecl GhcSe) where
+  put_ bh d = case d of
+    Warning a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XWarnDecl a   -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> Warning <$> get bh <*> get bh <*> get bh
+      1 -> XWarnDecl <$> get bh
+      _ -> getPanic "WarnDecl"
+
+instance Binary (RoleAnnotDecl GhcSe) where
+  put_ bh d = case d of
+    RoleAnnotDecl a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XRoleAnnotDecl a    -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> RoleAnnotDecl <$> get bh <*> get bh <*> get bh
+      1 -> XRoleAnnotDecl <$> get bh
+      _ -> getPanic "RoleAnnotDecl"
+
+instance Binary (RuleDecls GhcSe) where
+  put_ bh d = case d of
+    HsRules a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XRuleDecls a  -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsRules <$> get bh <*> get bh <*> get bh
+      1 -> XRuleDecls <$> get bh
+      _ -> getPanic "RuleDecls"
+
+instance Binary (RuleDecl GhcSe) where
+  put_ bh decl = case decl of
+    HsRule a b c d e f ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                   >> put_ bh e >> put_ bh f
+    XRuleDecl a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsRule <$> get bh <*> get bh <*> get bh <*> get bh
+                  <*> get bh <*> get bh
+      1 -> XRuleDecl <$> get bh
+      _ -> getPanic "RuleDecl"
+
+instance Binary (AnnDecl GhcSe) where
+  put_ bh decl = case decl of
+    HsAnnotation a b c d ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    XAnnDecl a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsAnnotation <$> get bh <*> get bh <*> get bh <*> get bh
+      1 -> XAnnDecl <$> get bh
+      _ -> getPanic "AnnDecl"
+
+instance Binary (SpliceDecl GhcSe) where
+  put_ bh d = case d of
+    SpliceDecl a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XSpliceDecl a    -> putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> SpliceDecl <$> get bh <*> get bh <*> get bh
+      1 -> XSpliceDecl <$> get bh
+      _ -> getPanic "SpliceDecl"
+
+instance Binary a => Binary (Tickish a) where
+  put_ bh t = case t of
+    ProfNote a b c ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    HpcTick a b ->
+      putByte bh 1 >> put_ bh a >> put_ bh b
+    Breakpoint a b ->
+      putByte bh 2 >> put_ bh a >> put_ bh b
+    SourceNote a b ->
+      putByte bh 3 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ProfNote <$> get bh <*> get bh <*> get bh
+      1 -> HpcTick <$> get bh <*> get bh
+      2 -> Breakpoint <$> get bh <*> get bh
+      3 -> SourceNote <$> get bh <*> get bh
+      _ -> getPanic "Tickish"
+
+instance Binary SpliceExplicitFlag where
+  put_ bh f = putByte bh $ case f of
+    ExplicitSplice -> 0
+    ImplicitSplice -> 1
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure ExplicitSplice
+      1 -> pure ImplicitSplice
+      _ -> getPanic "SpliceExplicitFlag"
+
+instance Binary SpliceDecoration where
+  put_ bh d = putByte bh $ case d of
+    HasParens -> 0
+    HasDollar -> 1
+    NoParens  -> 2
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure HasParens
+      1 -> pure HasDollar
+      2 -> pure NoParens
+      _ -> getPanic "SpliceDecoration"
+
+instance Binary (HsSplice GhcSe) where
+  put_ bh s = case s of
+    HsTypedSplice a b c d ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    HsUntypedSplice a b c d ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    HsQuasiQuote a b c d e ->
+      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                   >> put_ bh e
+    XSplice a ->
+      putByte bh 3 >> put_ bh a
+    HsSpliced {} -> putPanic "HsSplice" "HsSpliced"
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsTypedSplice <$> get bh <*> get bh <*> get bh <*> get bh
+      1 -> HsUntypedSplice <$> get bh <*> get bh <*> get bh <*> get bh
+      2 -> HsQuasiQuote <$> get bh <*> get bh <*> get bh <*> get bh
+                        <*> get bh
+      3 -> XSplice <$> get bh
+      _ -> getPanic "HsSplice"
+
+instance Binary (AnnProvenance SeName) where
+  put_ bh p = case p of
+    ValueAnnProvenance a -> putByte bh 0 >> put_ bh a
+    TypeAnnProvenance a -> putByte bh 1 >> put_ bh a
+    ModuleAnnProvenance -> putByte bh 2
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ValueAnnProvenance <$> get bh
+      1 -> TypeAnnProvenance <$> get bh
+      2 -> pure ModuleAnnProvenance
+      _ -> getPanic "AnnProvenance"
+
+instance Binary ForeignImport where
+  put_ bh (CImport a b c d e) =
+    put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+              >> put_ bh e
+  get bh = CImport <$> get bh <*> get bh <*> get bh
+                   <*> get bh <*> get bh
+
+instance Binary CImportSpec where
+  put_ bh s = case s of
+    CLabel a -> putByte bh 0 >> put_ bh a
+    CFunction a -> putByte bh 1 >> put_ bh a
+    CWrapper -> putByte bh 2
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> CLabel <$> get bh
+      1 -> CFunction <$> get bh
+      2 -> pure CWrapper
+      _ -> getPanic "CImportSpec"
+
+instance Binary ForeignExport where
+  put_ bh (CExport a b) = put_ bh a >> put_ bh b
+  get bh = CExport <$> get bh <*> get bh
+
+instance Binary (RuleBndr GhcSe) where
+  put_ bh b = case b of
+    RuleBndr a b ->
+      putByte bh 0 >> put_ bh a >> put_ bh b
+    RuleBndrSig a b c ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+    XRuleBndr a ->
+      putByte bh 2 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> RuleBndr <$> get bh <*> get bh
+      1 -> RuleBndrSig <$> get bh <*> get bh <*> get bh
+      2 -> XRuleBndr <$> get bh
+      _ -> getPanic "RuleBndr"
+
+instance (Binary a, Binary b) => Binary (FamEqn GhcSe a b) where
+  put_ bh e = case e of
+    FamEqn a b c d e ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                   >> put_ bh e
+    XFamEqn a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> FamEqn <$> get bh <*> get bh <*> get bh <*> get bh
+                  <*> get bh
+      1 -> XFamEqn <$> get bh
+      _ -> getPanic "FamEqn"
+
+instance Binary (HsDataDefn GhcSe) where
+  put_ bh d = case d of
+    HsDataDefn a b c d e f g ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                   >> put_ bh e >> put_ bh f >> put_ bh g
+    XHsDataDefn a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsDataDefn <$> get bh <*> get bh <*> get bh <*> get bh
+                      <*> get bh <*> get bh <*> get bh
+      1 -> XHsDataDefn <$> get bh
+      _ -> getPanic "HsDataDefn"
+
+instance Binary NewOrData where
+  put_ bh a = putByte bh (case a of
+    NewType  -> 0
+    DataType -> 1)
+  get bh = getByte bh >>= \b -> case b of
+    0 -> pure NewType
+    1 -> pure DataType
+    _ -> getPanic "NewOrData"
+
+instance Binary (HsDerivingClause GhcSe) where
+  put_ bh c = case c of
+    HsDerivingClause a b c ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XHsDerivingClause a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsDerivingClause <$> get bh <*> get bh <*> get bh
+      1 -> XHsDerivingClause <$> get bh
+      _ -> getPanic "HsDerivingClause"
+
+instance Binary (ConDecl GhcSe) where
+  put_ bh d = case d of
+    ConDeclGADT a b c d e f g h ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                   >> put_ bh e >> put_ bh f >> put_ bh g >> put_ bh h
+    ConDeclH98 a b c d e f g ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                   >> put_ bh e >> put_ bh f >> put_ bh g
+    XConDecl a ->
+      putByte bh 2 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ConDeclGADT <$> get bh <*> get bh <*> get bh <*> get bh
+                       <*> get bh <*> get bh <*> get bh <*> get bh
+      1 -> ConDeclH98 <$> get bh <*> get bh <*> get bh <*> get bh
+                      <*> get bh <*> get bh <*> get bh
+      2 -> XConDecl <$> get bh
+      _ -> getPanic "ConDecl"
+
+
+instance Binary (FamilyDecl GhcSe) where
+  put_ bh d = case d of
+    FamilyDecl a b c d e f g ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                   >> put_ bh e >> put_ bh f >> put_ bh g
+    XFamilyDecl a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> FamilyDecl <$> get bh <*> get bh <*> get bh <*> get bh
+                      <*> get bh <*> get bh <*> get bh
+      1 -> XFamilyDecl <$> get bh
+      _ -> getPanic "FamilyDecl"
+
+instance Binary (InjectivityAnn GhcSe) where
+  put_ bh a = case a of
+    InjectivityAnn a b -> put_ bh a >> put_ bh b
+  get bh = InjectivityAnn <$> get bh <*> get bh
+
+instance Binary (FamilyInfo GhcSe) where
+  put_ bh i = case i of
+    DataFamily ->
+      putByte bh 0
+    OpenTypeFamily ->
+      putByte bh 1
+    ClosedTypeFamily a ->
+      putByte bh 2 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure DataFamily
+      1 -> pure OpenTypeFamily
+      2 -> ClosedTypeFamily <$> get bh
+      _ -> getPanic "FamilyInfo"
+
+instance Binary (FamilyResultSig GhcSe) where
+  put_ bh s = case s of
+    NoSig a ->
+      putByte bh 0 >> put_ bh a
+    KindSig a b ->
+      putByte bh 1 >> put_ bh a >> put_ bh b
+    TyVarSig a b ->
+      putByte bh 2 >> put_ bh a >> put_ bh b
+    XFamilyResultSig a ->
+      putByte bh 3 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> NoSig <$> get bh
+      1 -> KindSig <$> get bh <*> get bh
+      2 -> TyVarSig <$> get bh <*> get bh
+      3 -> XFamilyResultSig <$> get bh
+      _ -> getPanic "FamilyResultSig"
+
+instance Binary (InstDecl GhcSe) where
+  put_ bh d = case d of
+    ClsInstD a b ->
+      putByte bh 0 >> put_ bh a >> put_ bh b
+    DataFamInstD a b ->
+      putByte bh 1 >> put_ bh a >> put_ bh b
+    TyFamInstD a b ->
+      putByte bh 2 >> put_ bh a >> put_ bh b
+    XInstDecl a ->
+      putByte bh 3 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ClsInstD <$> get bh <*> get bh
+      1 -> DataFamInstD <$> get bh <*> get bh
+      2 -> TyFamInstD <$> get bh <*> get bh
+      3 -> XInstDecl <$> get bh
+      _ -> getPanic "InstDecl"
+
+instance Binary (ClsInstDecl GhcSe) where
+  put_ bh d = case d of
+    ClsInstDecl a b c d e f g ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                   >> put_ bh e >> put_ bh f >> put_ bh g
+    XClsInstDecl a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ClsInstDecl <$> get bh <*> get bh <*> get bh <*> get bh
+                       <*> get bh <*> get bh <*> get bh
+      1 -> XClsInstDecl <$> get bh
+      _ -> getPanic "ClsInstDecl"
+
+instance Binary (DataFamInstDecl GhcSe) where
+  put_ bh (DataFamInstDecl a) = put_ bh a
+  get bh = DataFamInstDecl <$> get bh
+
+instance Binary (TyFamInstDecl GhcSe) where
+  put_ bh (TyFamInstDecl a) = put_ bh a
+  get bh = TyFamInstDecl <$> get bh
+
+instance Binary (DerivDecl GhcSe) where
+  put_ bh d = case d of
+    DerivDecl a b c d ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    XDerivDecl a ->
+      putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> DerivDecl <$> get bh <*> get bh <*> get bh <*> get bh
+      1 -> XDerivDecl <$> get bh
+      _ -> getPanic "DerivDecl"
+
+instance Binary (DerivStrategy GhcSe) where
+  put_ bh s = case s of
+    StockStrategy    -> putByte bh 0
+    AnyclassStrategy -> putByte bh 1
+    NewtypeStrategy  -> putByte bh 2
+    ViaStrategy a    -> putByte bh 3 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure StockStrategy
+      1 -> pure AnyclassStrategy
+      2 -> pure NewtypeStrategy
+      3 -> ViaStrategy <$> get bh
+      _ -> getPanic "DerivStrategy"
+
+instance Binary HsSrcBang where
+  put_ bh (HsSrcBang a b c) =
+    put_ bh a >> put_ bh b >> put_ bh c
+  get bh = HsSrcBang <$> get bh <*> get bh <*> get bh
+
+instance Binary RdrName where
+  put_ bh n = case n of
+    Unqual a -> putByte bh 0 >> put_ bh a
+    Qual a b -> putByte bh 1 >> put_ bh a >> put_ bh b
+    Orig a b -> putByte bh 2 >> put_ bh a >> put_ bh b
+    Exact a
+      | isExternalName a -> putByte bh 3 >> put_ bh a
+      | otherwise -> putByte bh (if isSystemName a then 4 else 5)
+          >> put_ bh (nameUnique a) >> put_ bh (nameOccName a)
+          >> put_ bh (nameSrcSpan a)
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> Unqual <$> get bh
+      1 -> Qual <$> get bh <*> get bh
+      2 -> Orig <$> get bh <*> get bh
+      3 -> Exact <$> get bh
+      4 -> fmap Exact (mkSystemNameAt <$> get bh <*> get bh <*> get bh)
+      5 -> fmap Exact (mkInternalName <$> get bh <*> get bh <*> get bh)
+      _ -> getPanic "RdrName"
+
+-- * HsLit
+
+instance Binary (HsLit GhcSe) where
+  put_ bh lit
+    = case lit of
+        HsChar a b       -> putByte bh 0  >> put_ bh a >> put_ bh b
+        HsCharPrim a b   -> putByte bh 1  >> put_ bh a >> put_ bh b
+        HsString a b     -> putByte bh 2  >> put_ bh a >> put_ bh b
+        HsStringPrim a b -> putByte bh 3  >> put_ bh a >> put_ bh b
+        HsInt a b        -> putByte bh 4  >> put_ bh a >> put_ bh b
+        HsIntPrim a b    -> putByte bh 5  >> put_ bh a >> put_ bh b
+        HsWordPrim a b   -> putByte bh 6  >> put_ bh a >> put_ bh b
+        HsInt64Prim a b  -> putByte bh 7  >> put_ bh a >> put_ bh b
+        HsWord64Prim a b -> putByte bh 8  >> put_ bh a >> put_ bh b
+        HsInteger a b c  -> putByte bh 9  >> put_ bh a >> put_ bh b >> put_ bh c
+        HsRat a b c      -> putByte bh 10 >> put_ bh a >> put_ bh b >> put_ bh c
+        HsFloatPrim a b  -> putByte bh 11 >> put_ bh a >> put_ bh b
+        HsDoublePrim a b -> putByte bh 12 >> put_ bh a >> put_ bh b
+        XLit a           -> putByte bh 13 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0  -> HsChar       <$> get bh <*> get bh
+      1  -> HsCharPrim   <$> get bh <*> get bh
+      2  -> HsString     <$> get bh <*> get bh
+      3  -> HsStringPrim <$> get bh <*> get bh
+      4  -> HsInt        <$> get bh <*> get bh
+      5  -> HsIntPrim    <$> get bh <*> get bh
+      6  -> HsWordPrim   <$> get bh <*> get bh
+      7  -> HsInt64Prim  <$> get bh <*> get bh
+      8  -> HsWord64Prim <$> get bh <*> get bh
+      9  -> HsInteger    <$> get bh <*> get bh <*> get bh
+      10 -> HsRat        <$> get bh <*> get bh <*> get bh
+      11 -> HsFloatPrim  <$> get bh <*> get bh
+      12 -> HsDoublePrim <$> get bh <*> get bh
+      13 -> XLit         <$> get bh
+      _ -> getPanic "HsLit"
+
+instance Binary (HsOverLit GhcSe) where
+  put_ bh lit = case lit of
+    OverLit a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    XOverLit a    -> putByte bh 1 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> OverLit <$> get bh <*> get bh <*> get bh
+      1 -> XOverLit <$> get bh
+      _ -> getPanic "HsOverLit"
+
+instance Binary Promoted where
+  get bh = getByte bh >>= \tag -> case tag of
+    0 -> pure Promoted
+    1 -> pure NotPromoted
+    _ -> getPanic "Promoted"
+
+  put_ bh p = putByte bh $ case p of
+    Promoted -> 0
+    NotPromoted -> 1
+
+instance Binary RealSrcLoc where
+  put_ bh l = do
+    put_ bh (srcLocFile l)
+    put_ bh (srcLocLine l)
+    put_ bh (srcLocCol l)
+
+  get bh = mkRealSrcLoc <$> get bh <*> get bh <*> get bh
+
+instance Binary RealSrcSpan where
+  put_ bh s = put_ bh (realSrcSpanStart s) >> put_ bh (realSrcSpanEnd s)
+
+  get bh = do
+    loc1 <- get bh
+    loc2 <- get bh
+    return (mkRealSrcSpan loc1 loc2)
+
+instance Binary OverLitVal where
+  put_ bh v
+    = case v of
+        HsIntegral a   -> putByte bh 0 >> put_ bh a
+        HsFractional a -> putByte bh 1 >> put_ bh a
+        HsIsString a b -> putByte bh 2 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsIntegral <$> get bh
+      1 -> HsFractional <$> get bh
+      2 -> HsIsString <$> get bh <*> get bh
+      _ -> getPanic "OverLitVal"
diff --git a/compiler/hsSyn/HsExtension.hs b/compiler/hsSyn/HsExtension.hs
index a7c467dce4..a488da00a7 100644
--- a/compiler/hsSyn/HsExtension.hs
+++ b/compiler/hsSyn/HsExtension.hs
@@ -23,10 +23,15 @@ import Data.Data hiding ( Fixity )
 import PlaceHolder
 import Name
 import RdrName
+import SeName
 import Var
+import IfaceType  ( IfaceType )
 import Outputable
 import SrcLoc (Located)
 
+import Data.Kind
+import qualified Type
+
 {-
 Note [Trees that grow]
 ~~~~~~~~~~~~~~~~~~~~~~
@@ -68,20 +73,22 @@ data GhcPass (c :: Pass)
 deriving instance Eq (GhcPass c)
 deriving instance Typeable c => Data (GhcPass c)
 
-data Pass = Parsed | Renamed | Typechecked
+data Pass = Parsed | Renamed | Typechecked | Serialisable
          deriving (Data)
 
 -- Type synonyms as a shorthand for tagging
-type GhcPs   = GhcPass 'Parsed      -- Old 'RdrName' type param
-type GhcRn   = GhcPass 'Renamed     -- Old 'Name' type param
-type GhcTc   = GhcPass 'Typechecked -- Old 'Id' type para,
-type GhcTcId = GhcTc                -- Old 'TcId' type param
+type GhcPs   = GhcPass 'Parsed       -- Old 'RdrName' type param
+type GhcRn   = GhcPass 'Renamed      -- Old 'Name' type param
+type GhcTc   = GhcPass 'Typechecked  -- Old 'Id' type para,
+type GhcSe   = GhcPass 'Serialisable -- New pass, with serialisable AST representations
+type GhcTcId = GhcTc                 -- Old 'TcId' type param
 
 -- | Maps the "normal" id type for a given pass
 type family IdP p
 type instance IdP GhcPs = RdrName
 type instance IdP GhcRn = Name
 type instance IdP GhcTc = Id
+type instance IdP GhcSe = SeName
 
 type LIdP p = Located (IdP p)
 
@@ -1105,4 +1112,34 @@ type OutputableBndrId id =
   ( OutputableBndr (NameOrRdrName (IdP id))
   , OutputableBndr (IdP id)
   , OutputableX id
+  , OutputableBndr (RdrOrSeName id)
+  , OutputableBndr (IdSigId id)
+  , VarType (IdSigId id)
   )
+
+class VarType a where
+  getVarType :: a -> Maybe Type.Type
+
+instance VarType Var where
+  getVarType = Just . varType
+
+instance VarType SeName where
+  getVarType _ = Nothing
+
+type family IdSigId pass where
+  IdSigId GhcSe       = SeName
+  IdSigId (GhcPass _) = Id
+
+type family LitType x where
+  LitType (GhcPass 'Serialisable) = IfaceType
+  LitType                       a = Type.Type
+
+type family DoName pass where
+  DoName GhcSe = SeName
+  DoName (GhcPass _) = Name
+
+type family RdrOrSeName pass
+type instance RdrOrSeName GhcSe = SeName
+type instance RdrOrSeName GhcRn = RdrName
+type instance RdrOrSeName GhcTc = RdrName
+type instance RdrOrSeName GhcPs = RdrName
diff --git a/compiler/hsSyn/HsImpExp.hs b/compiler/hsSyn/HsImpExp.hs
index 39bd9b7e18..9da47f62f1 100644
--- a/compiler/hsSyn/HsImpExp.hs
+++ b/compiler/hsSyn/HsImpExp.hs
@@ -12,6 +12,7 @@ HsImpExp: Abstract syntax: imports, exports, interfaces
 {-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE UndecidableInstances #-} -- Note [Pass sensitive types]
                                       -- in module PlaceHolder
+{-# LANGUAGE TypeFamilies #-}
 
 module HsImpExp where
 
diff --git a/compiler/hsSyn/HsLit.hs b/compiler/hsSyn/HsLit.hs
index d1411bd750..9546b0de30 100644
--- a/compiler/hsSyn/HsLit.hs
+++ b/compiler/hsSyn/HsLit.hs
@@ -13,7 +13,7 @@
                                       -- in module PlaceHolder
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE TypeFamilies #-}
-
+{-# LANGUAGE DataKinds #-}
 module HsLit where
 
 #include "HsVersions.h"
@@ -63,11 +63,11 @@ data HsLit x
       -- ^ literal @Int64#@
   | HsWord64Prim (XHsWord64Prim x) {- SourceText -} Integer
       -- ^ literal @Word64#@
-  | HsInteger (XHsInteger x) {- SourceText -} Integer Type
+  | HsInteger (XHsInteger x) {- SourceText -} Integer (LitType x)
       -- ^ Genuinely an integer; arises only
       -- from TRANSLATION (overloaded
       -- literals are done with HsOverLit)
-  | HsRat (XHsRat x)  FractionalLit Type
+  | HsRat (XHsRat x)  FractionalLit (LitType x)
       -- ^ Genuinely a rational; arises only from
       -- TRANSLATION (overloaded literals are
       -- done with HsOverLit)
@@ -128,6 +128,7 @@ data OverLitTc
 type instance XOverLit GhcPs = NoExt
 type instance XOverLit GhcRn = Bool            -- Note [ol_rebindable]
 type instance XOverLit GhcTc = OverLitTc
+type instance XOverLit GhcSe = NoExt
 
 type instance XXOverLit (GhcPass _) = NoExt
 
@@ -151,7 +152,7 @@ overLitType XOverLit{} = panic "overLitType"
 
 -- | Convert a literal from one index type to another, updating the annotations
 -- according to the relevant 'Convertable' instance
-convertLit :: (ConvertIdX a b) => HsLit a -> HsLit b
+convertLit :: (ConvertIdX a b, LitType a ~ LitType b) => HsLit a -> HsLit b
 convertLit (HsChar a x)       = (HsChar (convert a) x)
 convertLit (HsCharPrim a x)   = (HsCharPrim (convert a) x)
 convertLit (HsString a x)     = (HsString (convert a) x)
diff --git a/compiler/hsSyn/HsPat.hs b/compiler/hsSyn/HsPat.hs
index 6f65487411..aa7e9989a2 100644
--- a/compiler/hsSyn/HsPat.hs
+++ b/compiler/hsSyn/HsPat.hs
@@ -282,6 +282,7 @@ data ListPatTc
 type instance XWildPat GhcPs = NoExt
 type instance XWildPat GhcRn = NoExt
 type instance XWildPat GhcTc = Type
+type instance XWildPat GhcSe = NoExt
 
 type instance XVarPat  (GhcPass _) = NoExt
 type instance XLazyPat (GhcPass _) = NoExt
@@ -295,18 +296,22 @@ type instance XBangPat (GhcPass _) = NoExt
 type instance XListPat GhcPs = NoExt
 type instance XListPat GhcRn = Maybe (SyntaxExpr GhcRn)
 type instance XListPat GhcTc = ListPatTc
+type instance XListPat GhcSe = NoExt
 
 type instance XTuplePat GhcPs = NoExt
 type instance XTuplePat GhcRn = NoExt
 type instance XTuplePat GhcTc = [Type]
+type instance XTuplePat GhcSe = NoExt
 
 type instance XSumPat GhcPs = NoExt
 type instance XSumPat GhcRn = NoExt
 type instance XSumPat GhcTc = [Type]
+type instance XSumPat GhcSe = NoExt
 
 type instance XViewPat GhcPs = NoExt
 type instance XViewPat GhcRn = NoExt
 type instance XViewPat GhcTc = Type
+type instance XViewPat GhcSe = NoExt
 
 type instance XSplicePat (GhcPass _) = NoExt
 type instance XLitPat    (GhcPass _) = NoExt
@@ -314,14 +319,17 @@ type instance XLitPat    (GhcPass _) = NoExt
 type instance XNPat GhcPs = NoExt
 type instance XNPat GhcRn = NoExt
 type instance XNPat GhcTc = Type
+type instance XNPat GhcSe = NoExt
 
 type instance XNPlusKPat GhcPs = NoExt
 type instance XNPlusKPat GhcRn = NoExt
 type instance XNPlusKPat GhcTc = Type
+type instance XNPlusKPat GhcSe = NoExt
 
 type instance XSigPat GhcPs = (LHsSigWcType GhcPs)
 type instance XSigPat GhcRn = (LHsSigWcType GhcRn)
 type instance XSigPat GhcTc = Type
+type instance XSigPat GhcSe = (LHsSigWcType GhcSe)
 
 type instance XCoPat  (GhcPass _) = NoExt
 type instance XXPat   (GhcPass _) = NoExt
@@ -457,7 +465,9 @@ hsRecFieldSel = fmap extFieldOcc . hsRecFieldLbl
 hsRecFieldId :: HsRecField GhcTc arg -> Located Id
 hsRecFieldId = hsRecFieldSel
 
-hsRecUpdFieldRdr :: HsRecUpdField (GhcPass p) -> Located RdrName
+hsRecUpdFieldRdr
+  :: RdrOrSeName (GhcPass p) ~ RdrName
+  => HsRecUpdField (GhcPass p) -> Located RdrName
 hsRecUpdFieldRdr = fmap rdrNameAmbiguousFieldOcc . hsRecFieldLbl
 
 hsRecUpdFieldId :: HsRecField' (AmbiguousFieldOcc GhcTc) arg -> Located Id
@@ -557,7 +567,7 @@ pprConArgs (InfixCon p1 p2) = sep [ pprParendLPat appPrec p1
                                   , pprParendLPat appPrec p2 ]
 pprConArgs (RecCon rpats)   = ppr rpats
 
-instance (Outputable arg)
+instance (Outputable arg, Outputable (RdrOrSeName p))
       => Outputable (HsRecFields p arg) where
   ppr (HsRecFields { rec_flds = flds, rec_dotdot = Nothing })
         = braces (fsep (punctuate comma (map ppr flds)))
diff --git a/compiler/hsSyn/HsPat.hs-boot b/compiler/hsSyn/HsPat.hs-boot
index b7efb1c28c..d56a992207 100644
--- a/compiler/hsSyn/HsPat.hs-boot
+++ b/compiler/hsSyn/HsPat.hs-boot
@@ -4,7 +4,7 @@
                                       -- in module PlaceHolder
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE RoleAnnotations #-}
-{-# LANGUAGE TypeFamilies #-}
+{-# LANGUAGE TypeFamilies #-} -- needed to use OutputableBndrId
 
 module HsPat where
 import SrcLoc( Located )
diff --git a/compiler/hsSyn/HsTypes.hs b/compiler/hsSyn/HsTypes.hs
index 3512bf7a7c..2366df1d28 100644
--- a/compiler/hsSyn/HsTypes.hs
+++ b/compiler/hsSyn/HsTypes.hs
@@ -9,6 +9,7 @@ HsTypes: Abstract syntax: user-defined types
 {-# LANGUAGE DeriveDataTypeable #-}
 {-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE StandaloneDeriving #-}
+{-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE TypeSynonymInstances #-}
 {-# LANGUAGE UndecidableInstances #-} -- Note [Pass sensitive types]
                                       -- in module PlaceHolder
@@ -38,7 +39,7 @@ module HsTypes (
 
         HsConDetails(..),
 
-        FieldOcc(..), LFieldOcc, mkFieldOcc,
+        FieldOcc(..), LFieldOcc, mkFieldOcc, fieldOccRdrName,
         AmbiguousFieldOcc(..), mkAmbiguousFieldOcc,
         rdrNameAmbiguousFieldOcc, selectorAmbiguousFieldOcc,
         unambiguousFieldOcc, ambiguousFieldOcc,
@@ -85,6 +86,7 @@ import TysPrim( funTyConName )
 import Type
 import HsDoc
 import BasicTypes
+import Binary
 import SrcLoc
 import Outputable
 import FastString
@@ -277,6 +279,7 @@ data HsQTvsRn
 type instance XHsQTvs       GhcPs = NoExt
 type instance XHsQTvs       GhcRn = HsQTvsRn
 type instance XHsQTvs       GhcTc = HsQTvsRn
+type instance XHsQTvs       GhcSe = NoExt
 
 type instance XXLHsQTyVars  (GhcPass _) = NoExt
 
@@ -316,6 +319,7 @@ data HsIBRn
 type instance XHsIB              GhcPs _ = NoExt
 type instance XHsIB              GhcRn _ = HsIBRn
 type instance XHsIB              GhcTc _ = HsIBRn
+type instance XHsIB              GhcSe _ = NoExt
 
 type instance XXHsImplicitBndrs  (GhcPass _) _ = NoExt
 
@@ -337,6 +341,7 @@ data HsWildCardBndrs pass thing
 type instance XHsWC              GhcPs b = NoExt
 type instance XHsWC              GhcRn b = [Name]
 type instance XHsWC              GhcTc b = [Name]
+type instance XHsWC              GhcSe b = NoExt
 
 type instance XXHsWildCardBndrs  (GhcPass _) b = NoExt
 
@@ -415,6 +420,10 @@ newtype HsIPName = HsIPName FastString
 hsIPNameFS :: HsIPName -> FastString
 hsIPNameFS (HsIPName n) = n
 
+instance Binary HsIPName where
+  put_ bh (HsIPName s) = put_ bh s
+  get bh = HsIPName <$> get bh
+
 instance Outputable HsIPName where
     ppr (HsIPName n) = char '?' <> ftext n -- Ordinary implicit parameters
 
@@ -659,6 +668,7 @@ type instance XKindSig         (GhcPass _) = NoExt
 type instance XSpliceTy        GhcPs = NoExt
 type instance XSpliceTy        GhcRn = NoExt
 type instance XSpliceTy        GhcTc = Kind
+type instance XSpliceTy        GhcSe = NoExt
 
 type instance XDocTy           (GhcPass _) = NoExt
 type instance XBangTy          (GhcPass _) = NoExt
@@ -667,16 +677,19 @@ type instance XRecTy           (GhcPass _) = NoExt
 type instance XExplicitListTy  GhcPs = NoExt
 type instance XExplicitListTy  GhcRn = NoExt
 type instance XExplicitListTy  GhcTc = Kind
+type instance XExplicitListTy  GhcSe = NoExt
 
 type instance XExplicitTupleTy GhcPs = NoExt
 type instance XExplicitTupleTy GhcRn = NoExt
 type instance XExplicitTupleTy GhcTc = [Kind]
+type instance XExplicitTupleTy GhcSe = NoExt
 
 type instance XTyLit           (GhcPass _) = NoExt
 
 type instance XWildCardTy      GhcPs = NoExt
 type instance XWildCardTy      GhcRn = HsWildCardInfo
 type instance XWildCardTy      GhcTc = HsWildCardInfo
+type instance XWildCardTy      GhcSe = NoExt
 
 type instance XXType         (GhcPass _) = NewHsTypeX
 
@@ -1137,27 +1150,32 @@ type LFieldOcc pass = Located (FieldOcc pass)
 -- both the 'RdrName' the user originally wrote, and after the
 -- renamer, the selector function.
 data FieldOcc pass = FieldOcc { extFieldOcc     :: XCFieldOcc pass
-                              , rdrNameFieldOcc :: Located RdrName
+                              , rdrNameFieldOcc :: Located (RdrOrSeName pass)
                                  -- ^ See Note [Located RdrNames] in HsExpr
                               }
 
   | XFieldOcc
       (XXFieldOcc pass)
-deriving instance (p ~ GhcPass pass, Eq (XCFieldOcc p)) => Eq  (FieldOcc p)
-deriving instance (p ~ GhcPass pass, Ord (XCFieldOcc p)) => Ord (FieldOcc p)
+deriving instance (p ~ GhcPass pass, Eq (XCFieldOcc p), Eq (RdrOrSeName p))
+               => Eq  (FieldOcc p)
+deriving instance (p ~ GhcPass pass, Ord (XCFieldOcc p), Ord (RdrOrSeName p))
+               => Ord (FieldOcc p)
 
 type instance XCFieldOcc GhcPs = NoExt
 type instance XCFieldOcc GhcRn = Name
 type instance XCFieldOcc GhcTc = Id
+type instance XCFieldOcc GhcSe = NoExt
 
 type instance XXFieldOcc (GhcPass _) = NoExt
 
-instance Outputable (FieldOcc pass) where
+instance Outputable (RdrOrSeName pass) => Outputable (FieldOcc pass) where
   ppr = ppr . rdrNameFieldOcc
 
 mkFieldOcc :: Located RdrName -> FieldOcc GhcPs
 mkFieldOcc rdr = FieldOcc noExt rdr
 
+fieldOccRdrName :: RdrOrSeName pass ~ RdrName => FieldOcc pass -> Located RdrName
+fieldOccRdrName = rdrNameFieldOcc
 
 -- | Ambiguous Field Occurrence
 --
@@ -1172,31 +1190,36 @@ mkFieldOcc rdr = FieldOcc noExt rdr
 -- Note [Disambiguating record fields] in TcExpr.
 -- See Note [Located RdrNames] in HsExpr
 data AmbiguousFieldOcc pass
-  = Unambiguous (XUnambiguous pass) (Located RdrName)
-  | Ambiguous   (XAmbiguous pass)   (Located RdrName)
+  = Unambiguous (XUnambiguous pass) (Located (RdrOrSeName pass))
+  | Ambiguous   (XAmbiguous pass)   (Located (RdrOrSeName pass))
   | XAmbiguousFieldOcc (XXAmbiguousFieldOcc pass)
 
 type instance XUnambiguous GhcPs = NoExt
 type instance XUnambiguous GhcRn = Name
 type instance XUnambiguous GhcTc = Id
+type instance XUnambiguous GhcSe = NoExt
 
 type instance XAmbiguous GhcPs = NoExt
 type instance XAmbiguous GhcRn = NoExt
 type instance XAmbiguous GhcTc = Id
+type instance XAmbiguous GhcSe = NoExt
 
 type instance XXAmbiguousFieldOcc (GhcPass _) = NoExt
 
-instance p ~ GhcPass pass => Outputable (AmbiguousFieldOcc p) where
+instance (p ~ GhcPass pass, Outputable (RdrOrSeName p))
+      => Outputable (AmbiguousFieldOcc p) where
   ppr = ppr . rdrNameAmbiguousFieldOcc
 
-instance p ~ GhcPass pass => OutputableBndr (AmbiguousFieldOcc p) where
+instance (p ~ GhcPass pass, OutputableBndr (RdrOrSeName p))
+      => OutputableBndr (AmbiguousFieldOcc p) where
   pprInfixOcc  = pprInfixOcc . rdrNameAmbiguousFieldOcc
   pprPrefixOcc = pprPrefixOcc . rdrNameAmbiguousFieldOcc
 
 mkAmbiguousFieldOcc :: Located RdrName -> AmbiguousFieldOcc GhcPs
 mkAmbiguousFieldOcc rdr = Unambiguous noExt rdr
 
-rdrNameAmbiguousFieldOcc :: AmbiguousFieldOcc (GhcPass p) -> RdrName
+rdrNameAmbiguousFieldOcc
+  :: AmbiguousFieldOcc (GhcPass p) -> RdrOrSeName (GhcPass p)
 rdrNameAmbiguousFieldOcc (Unambiguous _ (L _ rdr)) = rdr
 rdrNameAmbiguousFieldOcc (Ambiguous   _ (L _ rdr)) = rdr
 rdrNameAmbiguousFieldOcc (XAmbiguousFieldOcc _)
diff --git a/compiler/hsSyn/HsUtils.hs b/compiler/hsSyn/HsUtils.hs
index eba21cf1e2..be0a5281ab 100644
--- a/compiler/hsSyn/HsUtils.hs
+++ b/compiler/hsSyn/HsUtils.hs
@@ -1133,8 +1133,9 @@ hsTyClForeignBinders tycl_decls foreign_decls
     getSelectorNames (ns, fs) = map unLoc ns ++ map (extFieldOcc . unLoc) fs
 
 -------------------
-hsLTyClDeclBinders :: Located (TyClDecl pass)
-                   -> ([Located (IdP pass)], [LFieldOcc pass])
+hsLTyClDeclBinders
+  :: RdrOrSeName pass ~ RdrName
+  => Located (TyClDecl pass) -> ([Located (IdP pass)], [LFieldOcc pass])
 -- ^ Returns all the /binding/ names of the decl.  The first one is
 -- guaranteed to be the name of the decl. The first component
 -- represents all binding names except record fields; the second
@@ -1188,7 +1189,8 @@ getPatSynBinds binds
           , L _ (PatSynBind _ psb) <- bagToList lbinds ]
 
 -------------------
-hsLInstDeclBinders :: LInstDecl (GhcPass p)
+hsLInstDeclBinders :: RdrOrSeName (GhcPass p) ~ RdrName
+                   => LInstDecl (GhcPass p)
                    -> ([Located (IdP (GhcPass p))], [LFieldOcc (GhcPass p)])
 hsLInstDeclBinders (L _ (ClsInstD { cid_inst = ClsInstDecl { cid_datafam_insts = dfis } }))
   = foldMap (hsDataFamInstBinders . unLoc) dfis
@@ -1202,8 +1204,9 @@ hsLInstDeclBinders (L _ (XInstDecl _))
 
 -------------------
 -- the SrcLoc returned are for the whole declarations, not just the names
-hsDataFamInstBinders :: DataFamInstDecl pass
-                     -> ([Located (IdP pass)], [LFieldOcc pass])
+hsDataFamInstBinders
+  :: RdrOrSeName pass ~ RdrName
+  => DataFamInstDecl pass -> ([Located (IdP pass)], [LFieldOcc pass])
 hsDataFamInstBinders (DataFamInstDecl { dfid_eqn = HsIB { hsib_body =
                        FamEqn { feqn_rhs = defn }}})
   = hsDataDefnBinders defn
@@ -1216,7 +1219,9 @@ hsDataFamInstBinders (DataFamInstDecl (XHsImplicitBndrs _))
 
 -------------------
 -- the SrcLoc returned are for the whole declarations, not just the names
-hsDataDefnBinders :: HsDataDefn pass -> ([Located (IdP pass)], [LFieldOcc pass])
+hsDataDefnBinders
+  :: RdrOrSeName pass ~ RdrName
+  => HsDataDefn pass -> ([Located (IdP pass)], [LFieldOcc pass])
 hsDataDefnBinders (HsDataDefn { dd_cons = cons })
   = hsConDeclsBinders cons
   -- See Note [Binders in family instances]
@@ -1226,7 +1231,9 @@ hsDataDefnBinders (XHsDataDefn _) = panic "hsDataDefnBinders"
 type Seen pass = [LFieldOcc pass] -> [LFieldOcc pass]
                  -- Filters out ones that have already been seen
 
-hsConDeclsBinders :: [LConDecl pass] -> ([Located (IdP pass)], [LFieldOcc pass])
+hsConDeclsBinders
+  :: forall pass. RdrOrSeName pass ~ RdrName
+  => [LConDecl pass] -> ([Located (IdP pass)], [LFieldOcc pass])
    -- See hsLTyClDeclBinders for what this does
    -- The function is boringly complicated because of the records
    -- And since we only have equality, we have to be a little careful
diff --git a/compiler/hsSyn/PlaceHolder.hs b/compiler/hsSyn/PlaceHolder.hs
index 244243a82f..e05dfc3a33 100644
--- a/compiler/hsSyn/PlaceHolder.hs
+++ b/compiler/hsSyn/PlaceHolder.hs
@@ -9,6 +9,7 @@ module PlaceHolder where
 import Name
 import NameSet
 import RdrName
+import SeName
 import Var
 
 
@@ -68,3 +69,4 @@ type family NameOrRdrName id where
   NameOrRdrName Id      = Name
   NameOrRdrName Name    = Name
   NameOrRdrName RdrName = RdrName
+  NameOrRdrName SeName  = SeName
diff --git a/compiler/hsSyn/SeName.hs b/compiler/hsSyn/SeName.hs
new file mode 100644
index 0000000000..f8bca59243
--- /dev/null
+++ b/compiler/hsSyn/SeName.hs
@@ -0,0 +1,13 @@
+{-# LANGUAGE GeneralizedNewtypeDeriving #-}
+module SeName (SeName(..), mkSeName) where
+
+import Outputable
+import RdrName
+
+-- TODO: make this smarter, so as to check whether
+-- the name is local or not.
+newtype SeName = SeName RdrName
+  deriving (Outputable, OutputableBndr)
+
+mkSeName :: RdrName -> SeName
+mkSeName = SeName
diff --git a/compiler/iface/IfaceEnv.hs b/compiler/iface/IfaceEnv.hs
index 00bcaa77f1..2d6047d7cc 100644
--- a/compiler/iface/IfaceEnv.hs
+++ b/compiler/iface/IfaceEnv.hs
@@ -16,7 +16,7 @@ module IfaceEnv (
         ifaceExportNames,
 
         -- Name-cache stuff
-        allocateGlobalBinder, updNameCacheTc,
+        allocateGlobalBinder, updNameCacheTc, updNameCacheIO,
         mkNameCacheUpdater, NameCacheUpdater(..),
    ) where
 
diff --git a/compiler/iface/IfaceType.hs b/compiler/iface/IfaceType.hs
index 5a7f761d32..15a19b117f 100644
--- a/compiler/iface/IfaceType.hs
+++ b/compiler/iface/IfaceType.hs
@@ -139,7 +139,7 @@ type IfaceContext = [IfacePredType]
 data IfaceTyLit
   = IfaceNumTyLit Integer
   | IfaceStrTyLit FastString
-  deriving (Eq)
+  deriving Eq
 
 type IfaceTyConBinder = TyVarBndr IfaceTvBndr TyConBndrVis
 type IfaceForAllBndr  = TyVarBndr IfaceTvBndr ArgFlag
@@ -170,7 +170,7 @@ instance Monoid IfaceTcArgs where
 -- properly.
 data IfaceTyCon = IfaceTyCon { ifaceTyConName :: IfExtName
                              , ifaceTyConInfo :: IfaceTyConInfo }
-    deriving (Eq)
+    deriving Eq
 
 -- | Is a TyCon a promoted data constructor or just a normal type constructor?
 data IsPromoted = IsNotPromoted | IsPromoted
@@ -194,7 +194,7 @@ data IfaceTyConSort = IfaceNormalTyCon          -- ^ a regular tycon
                       -- that is actually being applied to two types
                       -- of the same kind.  This affects pretty-printing
                       -- only: see Note [Equality predicates in IfaceType]
-                    deriving (Eq)
+                    deriving Eq
 
 {- Note [Free tyvars in IfaceType]
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -278,7 +278,7 @@ data IfaceTyConInfo   -- Used to guide pretty-printing
                       -- and to disambiguate D from 'D (they share a name)
   = IfaceTyConInfo { ifaceTyConIsPromoted :: IsPromoted
                    , ifaceTyConSort       :: IfaceTyConSort }
-    deriving (Eq)
+    deriving Eq
 
 data IfaceCoercion
   = IfaceReflCo       Role IfaceType
@@ -1650,6 +1650,7 @@ instance Binary IfaceUnivCoProv where
            _ -> panic ("get IfaceUnivCoProv " ++ show tag)
 
 
+{-
 instance Binary (DefMethSpec IfaceType) where
     put_ bh VanillaDM     = putByte bh 0
     put_ bh (GenericDM t) = putByte bh 1 >> put_ bh t
@@ -1658,3 +1659,4 @@ instance Binary (DefMethSpec IfaceType) where
             case h of
               0 -> return VanillaDM
               _ -> do { t <- get bh; return (GenericDM t) }
+-}
diff --git a/compiler/main/DynFlags.hs b/compiler/main/DynFlags.hs
index 539132653e..5f217a6a8f 100644
--- a/compiler/main/DynFlags.hs
+++ b/compiler/main/DynFlags.hs
@@ -916,6 +916,8 @@ data DynFlags = DynFlags {
   hiDir                 :: Maybe String,
   stubDir               :: Maybe String,
   dumpDir               :: Maybe String,
+  saveSplicesDir        :: Maybe String,
+  loadSplicesDir        :: Maybe String,
 
   objectSuf             :: String,
   hcSuf                 :: String,
@@ -1797,6 +1799,8 @@ defaultDynFlags mySettings (myLlvmTargets, myLlvmPasses) =
         hiDir                   = Nothing,
         stubDir                 = Nothing,
         dumpDir                 = Nothing,
+        saveSplicesDir          = Nothing,
+        loadSplicesDir          = Nothing,
 
         objectSuf               = phaseInputExt StopLn,
         hcSuf                   = phaseInputExt HCc,
@@ -2371,6 +2375,7 @@ getVerbFlags dflags
   | otherwise             = []
 
 setObjectDir, setHiDir, setStubDir, setDumpDir, setOutputDir,
+         setSaveSplicesDir, setLoadSplicesDir,
          setDynObjectSuf, setDynHiSuf,
          setDylibInstallName,
          setObjectSuf, setHiSuf, setHcSuf, parseDynLibLoaderMode,
@@ -2390,6 +2395,8 @@ setStubDir    f d = d { stubDir    = Just f
   -- builds).
 setDumpDir    f d = d { dumpDir    = Just f}
 setOutputDir  f = setObjectDir f . setHiDir f . setStubDir f . setDumpDir f
+setSaveSplicesDir f d = d { saveSplicesDir = Just f}
+setLoadSplicesDir f d = d { loadSplicesDir = Just f}
 setDylibInstallName  f d = d { dylibInstallName = Just f}
 
 setObjectSuf    f d = d { objectSuf    = f}
@@ -2948,6 +2955,8 @@ dynamic_flags_deps = [
   , make_ord_flag defGhcFlag "tmpdir"            (hasArg setTmpDir)
   , make_ord_flag defGhcFlag "stubdir"           (hasArg setStubDir)
   , make_ord_flag defGhcFlag "dumpdir"           (hasArg setDumpDir)
+  , make_ord_flag defGhcFlag "save-splices"      (hasArg setSaveSplicesDir)
+  , make_ord_flag defGhcFlag "load-splices"      (hasArg setLoadSplicesDir)
   , make_ord_flag defGhcFlag "outputdir"         (hasArg setOutputDir)
   , make_ord_flag defGhcFlag "ddump-file-prefix"
         (hasArg (setDumpPrefixForce . Just))
diff --git a/compiler/prelude/PrimOp.hs-boot b/compiler/prelude/PrimOp.hs-boot
index f10ef44972..6d759bb961 100644
--- a/compiler/prelude/PrimOp.hs-boot
+++ b/compiler/prelude/PrimOp.hs-boot
@@ -1,5 +1,7 @@
 module PrimOp where
 
-import GhcPrelude ()
+import GhcPrelude (Int)
 
 data PrimOp
+primOpTag :: PrimOp -> Int
+allThePrimOps :: [PrimOp]
diff --git a/compiler/rename/RnPat.hs b/compiler/rename/RnPat.hs
index 6195309cab..63c471d3ef 100644
--- a/compiler/rename/RnPat.hs
+++ b/compiler/rename/RnPat.hs
@@ -743,7 +743,7 @@ rnHsRecUpdFields flds
 getFieldIds :: [LHsRecField GhcRn arg] -> [Name]
 getFieldIds flds = map (unLoc . hsRecFieldSel . unLoc) flds
 
-getFieldLbls :: [LHsRecField id arg] -> [RdrName]
+getFieldLbls :: RdrOrSeName id ~ RdrName => [LHsRecField id arg] -> [RdrName]
 getFieldLbls flds
   = map (unLoc . rdrNameFieldOcc . unLoc . hsRecFieldLbl . unLoc) flds
 
diff --git a/compiler/typecheck/Inst.hs b/compiler/typecheck/Inst.hs
index f8f3bbe191..91d88087f8 100644
--- a/compiler/typecheck/Inst.hs
+++ b/compiler/typecheck/Inst.hs
@@ -7,7 +7,7 @@ The @Inst@ type: dictionaries or method instances
 -}
 
 {-# LANGUAGE CPP, MultiWayIf, TupleSections #-}
-{-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE FlexibleContexts, TypeFamilies #-}
 
 module Inst (
        deeplySkolemise,
diff --git a/compiler/typecheck/TcEnv.hs b/compiler/typecheck/TcEnv.hs
index b42557259e..00dcf26f09 100644
--- a/compiler/typecheck/TcEnv.hs
+++ b/compiler/typecheck/TcEnv.hs
@@ -1,6 +1,6 @@
 -- (c) The University of Glasgow 2006
 {-# LANGUAGE CPP, FlexibleInstances #-}
-{-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE FlexibleContexts, GADTs #-}
 {-# OPTIONS_GHC -fno-warn-orphans #-}  -- instance MonadThings is necessarily an
                                        -- orphan
 {-# LANGUAGE UndecidableInstances #-} -- Note [Pass sensitive types]
diff --git a/compiler/typecheck/TcHsSyn.hs b/compiler/typecheck/TcHsSyn.hs
index 986047bded..1cca6f5589 100644
--- a/compiler/typecheck/TcHsSyn.hs
+++ b/compiler/typecheck/TcHsSyn.hs
@@ -114,7 +114,7 @@ hsPatType (NPlusKPat ty _ _ _ _ _)      = ty
 hsPatType (CoPat _ _ _ ty)              = ty
 hsPatType p                             = pprPanic "hsPatType" (ppr p)
 
-hsLitType :: HsLit (GhcPass p) -> TcType
+hsLitType :: LitType (GhcPass p) ~ TcType => HsLit (GhcPass p) -> TcType
 hsLitType (HsChar _ _)       = charTy
 hsLitType (HsCharPrim _ _)   = charPrimTy
 hsLitType (HsString _ _)     = stringTy
diff --git a/compiler/typecheck/TcRnDriver.hs b/compiler/typecheck/TcRnDriver.hs
index 2f81e07990..5a048d0c4b 100644
--- a/compiler/typecheck/TcRnDriver.hs
+++ b/compiler/typecheck/TcRnDriver.hs
@@ -47,7 +47,7 @@ module TcRnDriver (
 
 import GhcPrelude
 
-import {-# SOURCE #-} TcSplice ( finishTH )
+import {-# SOURCE #-} TcSplice( finishTH, writeHsSpliceData )
 import RnSplice ( rnTopSpliceDecls, traceSplice, SpliceInfo(..) )
 import IfaceEnv( externaliseName )
 import TcHsType
@@ -114,6 +114,7 @@ import Avail
 import TyCon
 import SrcLoc
 import HscTypes
+import HsExprBin
 import ListSetOps
 import Outputable
 import ConLike
@@ -137,6 +138,8 @@ import qualified Data.Set as S
 
 import Control.DeepSeq
 import Control.Monad
+import System.Directory
+import System.FilePath (takeDirectory)
 
 #include "HsVersions.h"
 
@@ -421,6 +424,17 @@ tcRnSrcDecls explicit_mod_hdr decls
         -- Finalizers must run after constraints are simplified, or some types
         -- might not be complete when using reify (see #12777).
       ; (tcg_env, tcl_env) <- setGblEnv tcg_env run_th_modfinalizers
+
+      ; dynflags <- getDynFlags
+      ; whenSet (saveSplicesDir dynflags)
+          (\splicesDir -> do
+              moduleSplicesPath <- getModuleSplicesPath splicesDir <$> getModule
+              hs_splice_data <- readTcRef (tcg_hs_splice_data tcg_env)
+              liftIO $ createDirectoryIfMissing True (takeDirectory moduleSplicesPath)
+              writeHsSpliceData moduleSplicesPath hs_splice_data
+          )
+          (pure ())
+
       ; setEnvs (tcg_env, tcl_env) $ do {
 
       ; finishTH
diff --git a/compiler/typecheck/TcRnMonad.hs b/compiler/typecheck/TcRnMonad.hs
index e0989ae331..83449f1631 100644
--- a/compiler/typecheck/TcRnMonad.hs
+++ b/compiler/typecheck/TcRnMonad.hs
@@ -145,6 +145,7 @@ import IOEnv            -- Re-export all
 import TcEvidence
 
 import HsSyn hiding (LIE)
+import HsExprBin
 import HscTypes
 import Module
 import RdrName
@@ -182,7 +183,7 @@ import Control.Monad
 import Data.Set ( Set )
 import qualified Data.Set as Set
 
-import {-# SOURCE #-} TcSplice ( runRemoteModFinalizers )
+import {-# SOURCE #-} TcSplice ( readHsSpliceData, runRemoteModFinalizers )
 import {-# SOURCE #-} TcEnv    ( tcInitTidyEnv )
 
 import qualified Data.Map as Map
@@ -228,9 +229,16 @@ initTc hsc_env hsc_src keep_rn_syntax mod loc do_this
         th_coreplugins_var <- newIORef [] ;
         th_state_var         <- newIORef Map.empty ;
         th_remote_state_var  <- newIORef Nothing ;
+        dflags <- pure (hsc_dflags hsc_env) ;
+        hs_splice_data <- newIORef =<< whenSet (loadSplicesDir dflags)
+          (\splicesDir -> do
+              if moduleUnitId mod == interactiveUnitId
+                then return emptyHsSpliceData
+                else do let moduleSplicesPath = getModuleSplicesPath splicesDir mod
+                        readHsSpliceData hsc_env moduleSplicesPath
+          )
+          (pure emptyHsSpliceData) ;
         let {
-             dflags = hsc_dflags hsc_env ;
-
              maybe_rn_syntax :: forall a. a -> Maybe a ;
              maybe_rn_syntax empty_val
                 | dopt Opt_D_dump_rn_ast dflags = Just empty_val
@@ -310,7 +318,8 @@ initTc hsc_env hsc_src keep_rn_syntax mod loc do_this
                 tcg_top_loc        = loc,
                 tcg_static_wc      = static_wc_var,
                 tcg_complete_matches = [],
-                tcg_cc_st          = cc_st_var
+                tcg_cc_st          = cc_st_var,
+                tcg_hs_splice_data = hs_splice_data
              } ;
         } ;
 
diff --git a/compiler/typecheck/TcRnTypes.hs b/compiler/typecheck/TcRnTypes.hs
index 2a4b808f54..08ed9f151d 100644
--- a/compiler/typecheck/TcRnTypes.hs
+++ b/compiler/typecheck/TcRnTypes.hs
@@ -160,6 +160,7 @@ import TyCoRep  ( CoercionHole(..), coHoleCoVar )
 import Coercion ( Coercion, mkHoleCo )
 import ConLike  ( ConLike(..) )
 import DataCon  ( DataCon, dataConUserType, dataConOrigArgTys )
+import {-# SOURCE #-} HsExprBin
 import PatSyn   ( PatSyn, pprPatSynType )
 import Id       ( idType, idName )
 import FieldLabel ( FieldLabel )
@@ -689,7 +690,19 @@ data TcGblEnv
         tcg_complete_matches :: [CompleteMatch],
 
         -- ^ Tracking indices for cost centre annotations
-        tcg_cc_st   :: TcRef CostCentreState
+        tcg_cc_st   :: TcRef CostCentreState,
+        -- ^ Splice evaluation results
+        --
+        -- When @-save-splices@ is passed, we will
+        -- record splice results in this field and write
+        -- them all to an .hs-splice file when we are done
+        -- processing the module.
+        --
+        -- When @-load-splices@ is passed, we will read
+        -- the .hs-splice file before we start processing a
+        -- module (when it exists) and store all its contents
+        -- in this field.
+        tcg_hs_splice_data :: TcRef HsSpliceData
     }
 
 -- NB: topModIdentity, not topModSemantic!
diff --git a/compiler/typecheck/TcSplice.hs b/compiler/typecheck/TcSplice.hs
index 737ddccfbd..c6dd542937 100644
--- a/compiler/typecheck/TcSplice.hs
+++ b/compiler/typecheck/TcSplice.hs
@@ -26,6 +26,7 @@ module TcSplice(
      runMetaE, runMetaP, runMetaT, runMetaD, runQuasi,
      tcTopSpliceExpr, lookupThName_maybe,
      defaultRunMeta, runMeta', runRemoteModFinalizers,
+     readHsSpliceData, writeHsSpliceData,
      finishTH
       ) where
 
@@ -34,6 +35,7 @@ module TcSplice(
 import GhcPrelude
 
 import HsSyn
+import HsExprBin
 import Annotations
 import Finder
 import Name
@@ -110,6 +112,9 @@ import Maybes( MaybeErr(..) )
 import DynFlags
 import Panic
 import Lexeme
+import BinIface ( getWithUserData, putWithUserData )
+import IfaceEnv ( NameCacheUpdater(..) )
+import qualified Binary as Bin
 import qualified EnumSet
 import Plugins
 import Bag
@@ -132,6 +137,7 @@ import Data.Typeable ( typeOf, Typeable, TypeRep, typeRep )
 import Data.Data (Data)
 import Data.Proxy    ( Proxy (..) )
 import GHC.Exts         ( unsafeCoerce# )
+import System.Directory ( doesFileExist )
 
 {-
 ************************************************************************
@@ -672,12 +678,26 @@ runQResult show_th f runQ expr_span hval
 
 
 -----------------
+
 runMeta :: (MetaHook TcM -> LHsExpr GhcTc -> TcM hs_syn)
+        -> (LHsExpr GhcTc -> TcM hs_syn)
+           -- ^ function to load the result of the given expression from
+           --   an .hs-splice file's data
+        -> (LHsExpr GhcTc -> hs_syn -> TcM ())
+           -- ^ function to "save" the result (hs_syn) of evaluating the given
+           --   LHsExpr
         -> LHsExpr GhcTc
         -> TcM hs_syn
-runMeta unwrap e
-  = do { h <- getHooked runMetaHook defaultRunMeta
-       ; unwrap h e }
+runMeta unwrap loadSpliceFun saveSpliceFun e
+  = do { dflags <- getDynFlags
+       ; whenSet (loadSplicesDir dflags)
+           (\_ -> loadSpliceFun e)
+           (do { h <- getHooked runMetaHook defaultRunMeta
+               ; res <- unwrap h e
+               ; whenSet (saveSplicesDir dflags)
+                   (\_ -> saveSpliceFun e res)
+                   (return ())
+               ; return res }) }
 
 defaultRunMeta :: MetaHook TcM
 defaultRunMeta (MetaE r)
@@ -694,29 +714,110 @@ defaultRunMeta (MetaAW r)
     -- the toAnnotationWrapper function that we slap around the user's code
 
 ----------------
+
+readHsSpliceData :: HscEnv -> FilePath -> IO HsSpliceData
+readHsSpliceData hsc_env hsSpliceFile = do
+  let ncu = NCU (updNameCache hsc_env)
+  exists <- doesFileExist hsSpliceFile
+  if exists
+    then do bh <- Bin.readBinMem hsSpliceFile
+            getWithUserData ncu bh
+    else pure emptyHsSpliceData
+
+writeHsSpliceData :: FilePath -> HsSpliceData -> TcM ()
+writeHsSpliceData hsSpliceFile hsSpliceData =
+  when (nonEmptyHsSpliceData hsSpliceData) $ do
+    dflags <- getDynFlags
+    liftIO $ do
+      bh <- Bin.openBinMem (100 * 1024)
+      --  ^^^ FIXME: how should we compute an approximation of size?
+      putWithUserData (debugTraceMsg dflags 3) bh hsSpliceData
+      Bin.writeBinMem bh hsSpliceFile
+
+-- | Update the splice data from the TcGblEnv using the given
+--   function. Used when -save-splices is passed, to record
+--   the splice results as we evaluate them and dump them
+--   to an .hs-splice file.
+modifyHsSpliceData :: (HsSpliceData -> HsSpliceData) -> TcM ()
+modifyHsSpliceData f = do
+  spliceDataRef <- tcg_hs_splice_data <$> getGblEnv
+  updTcRef spliceDataRef f
+
+-- | Record the result (second argument) of evaluating the expression splice
+--   represented by the first argument.
+addSpliceExprResult :: LHsExpr GhcTc -> LHsExpr GhcPs -> TcM ()
+addSpliceExprResult th@(L l _) resultE = do
+  serialExpr <- handleUnsupported (fmap ppr th) (Just $ ppr resultE)
+            =<< exprPS2SE resultE
+  modifyHsSpliceData $ recordSpliceResult l (SRExpr serialExpr)
+
+-- | Record the result (second argument) of evaluating the declaration splice
+--   represented by the first argument.
+addSpliceDeclsResult :: LHsExpr GhcTc -> [LHsDecl GhcPs] -> TcM ()
+addSpliceDeclsResult th@(L l _) resultDs = do
+  serialDecls <- traverse
+     (declPS2SE >=> handleUnsupported (fmap ppr th) (Just $ ppr resultDs))
+     resultDs
+  modifyHsSpliceData $ recordSpliceResult l (SRDecls serialDecls)
+
+-- | Look up the result of evaluating the splice represented by the first
+--   argument in an .hs-splice file, using the given function to extract
+--   the result in question (when found).
+getSpliceResult :: LHsExpr GhcTc -> (SpliceResult -> TcM a) -> TcM a
+getSpliceResult (L l _) f = do
+  gblEnv <- getGblEnv
+  hs_splice_data <- readTcRef (tcg_hs_splice_data gblEnv)
+  case lookupSpliceResult l hs_splice_data of
+    Nothing -> panic ("Could not find splice result for source span " ++ show l)
+    Just r  -> f r
+
+-- | Look up the result of evaluating an expression splice.
+getSpliceExprResult :: LHsExpr GhcTc -> TcM (LHsExpr GhcPs)
+getSpliceExprResult spliceE = getSpliceResult spliceE $ \res -> case res of
+    SRExpr e  -> exprSE2PS e >>= handleUnsupported (fmap ppr spliceE) Nothing
+    SRDecls _ -> panic ("Expected an expression splice but found a declaration one")
+
+-- | Look up the result of evaluating a declaration splice.
+getSpliceDeclsResult :: LHsExpr GhcTc -> TcM [LHsDecl GhcPs]
+getSpliceDeclsResult spliceE = getSpliceResult spliceE $ \res -> case res of
+    SRExpr _   -> panic ("Expected a declaration splice result but found an expression one")
+    SRDecls ds -> traverse
+      (declSE2PS >=> handleUnsupported (fmap ppr spliceE) Nothing)
+      ds
+
 runMetaAW :: LHsExpr GhcTc         -- Of type AnnotationWrapper
           -> TcM Serialized
 runMetaAW = runMeta metaRequestAW
+  -- We cannot process annotations as they use the same
+  -- mechanism as TH. Instead, we ignore them when
+  -- doing a -save-splices pass, and we pretend we
+  -- read {-# ANN () #-} when doing a -load-splices pass.
+  (\_ -> pure $ toSerialized serializeWithData ())
+  (\_ _ -> pure ())
 
 runMetaE :: LHsExpr GhcTc          -- Of type (Q Exp)
          -> TcM (LHsExpr GhcPs)
-runMetaE = runMeta metaRequestE
+runMetaE = runMeta metaRequestE getSpliceExprResult addSpliceExprResult
 
 runMetaP :: LHsExpr GhcTc          -- Of type (Q Pat)
          -> TcM (LPat GhcPs)
 runMetaP = runMeta metaRequestP
+  (panic "runMetaP doesn't support splice caching (read)")
+  (panic "runMetaP doesn't support splice caching (write)")
 
 runMetaT :: LHsExpr GhcTc          -- Of type (Q Type)
          -> TcM (LHsType GhcPs)
 runMetaT = runMeta metaRequestT
+  (panic "runMetaT doesn't support splice caching (read)")
+  (panic "runMetaT doesn't support splice caching (write)")
 
 runMetaD :: LHsExpr GhcTc          -- Of type Q [Dec]
          -> TcM [LHsDecl GhcPs]
-runMetaD = runMeta metaRequestD
+runMetaD = runMeta metaRequestD getSpliceDeclsResult addSpliceDeclsResult
 
 ---------------
 runMeta' :: Bool                 -- Whether code should be printed in the exception message
-         -> (hs_syn -> SDoc)                                    -- how to print the code
+         -> (hs_syn -> SDoc)     -- how to print the code
          -> (SrcSpan -> ForeignHValue -> TcM (Either MsgDoc hs_syn))        -- How to run x
          -> LHsExpr GhcTc        -- Of type x; typically x = Q TH.Exp, or
                                  --    something like that
@@ -727,7 +828,7 @@ runMeta' show_code ppr_hs run_and_convert expr
                             -- we catch all kinds of splices and annotations.
 
         -- Check that we've had no errors of any sort so far.
-        -- For example, if we found an error in an earlier defn f, but
+        -- For example, if we fouénd an error in an earlier defn f, but
         -- recovered giving it type f :: forall a.a, it'd be very dodgy
         -- to carry ont.  Mind you, the staging restrictions mean we won't
         -- actually run f, but it still seems wrong. And, more concretely,
diff --git a/compiler/typecheck/TcSplice.hs-boot b/compiler/typecheck/TcSplice.hs-boot
index be2c67d887..277dc95c8d 100644
--- a/compiler/typecheck/TcSplice.hs-boot
+++ b/compiler/typecheck/TcSplice.hs-boot
@@ -10,6 +10,8 @@ import TcRnTypes( TcM , SpliceType )
 import TcType   ( ExpRhoType )
 import Annotations ( Annotation, CoreAnnTarget )
 import HsExtension ( GhcTcId, GhcRn, GhcPs )
+import HscTypes    ( HscEnv )
+import HsExprBin   ( HsSpliceData )
 
 import HsSyn      ( HsSplice, HsBracket, HsExpr, LHsExpr, LHsType, LPat,
                     LHsDecl, ThModFinalizers )
@@ -42,3 +44,6 @@ lookupThName_maybe :: TH.Name -> TcM (Maybe Name)
 runQuasi :: TH.Q a -> TcM a
 runRemoteModFinalizers :: ThModFinalizers -> TcM ()
 finishTH :: TcM ()
+
+readHsSpliceData :: HscEnv -> FilePath -> IO HsSpliceData
+writeHsSpliceData :: FilePath -> HsSpliceData -> TcM ()
\ No newline at end of file
diff --git a/compiler/typecheck/TcType.hs-boot b/compiler/typecheck/TcType.hs-boot
index 2bc14735f1..1b014c2d2a 100644
--- a/compiler/typecheck/TcType.hs-boot
+++ b/compiler/typecheck/TcType.hs-boot
@@ -4,5 +4,6 @@ import Outputable( SDoc )
 data MetaDetails
 
 data TcTyVarDetails
+
 pprTcTyVarDetails :: TcTyVarDetails -> SDoc
 vanillaSkolemTv :: TcTyVarDetails
diff --git a/compiler/types/CoAxiom.hs b/compiler/types/CoAxiom.hs
index 63c21627c8..c8334ddd42 100644
--- a/compiler/types/CoAxiom.hs
+++ b/compiler/types/CoAxiom.hs
@@ -39,9 +39,9 @@ import Name
 import Unique
 import Var
 import Util
-import Binary
 import Pair
 import BasicTypes
+import Binary
 import Data.Typeable ( Typeable )
 import SrcLoc
 import qualified Data.Data as Data
@@ -440,15 +440,16 @@ instance Outputable Role where
   ppr = ftext . fsFromRole
 
 instance Binary Role where
-  put_ bh Nominal          = putByte bh 1
-  put_ bh Representational = putByte bh 2
-  put_ bh Phantom          = putByte bh 3
-
-  get bh = do tag <- getByte bh
-              case tag of 1 -> return Nominal
-                          2 -> return Representational
-                          3 -> return Phantom
-                          _ -> panic ("get Role " ++ show tag)
+  put_ bh r = putByte bh $ case r of
+    Nominal          -> 0
+    Representational -> 1
+    Phantom          -> 2
+  get bh = do
+    tag <- getByte bh
+    pure $ case tag of
+      0 -> Nominal
+      1 -> Representational
+      _ -> Phantom
 
 {-
 ************************************************************************
@@ -501,7 +502,6 @@ instance Ord CoAxiomRule where
 instance Outputable CoAxiomRule where
   ppr = ppr . coaxrName
 
-
 -- Type checking of built-in families
 data BuiltInSynFamily = BuiltInSynFamily
   { sfMatchFam      :: [Type] -> Maybe (CoAxiomRule, [Type], Type)
diff --git a/compiler/types/TyCon.hs b/compiler/types/TyCon.hs
index 82c9082ac1..786e77ef63 100644
--- a/compiler/types/TyCon.hs
+++ b/compiler/types/TyCon.hs
@@ -584,7 +584,6 @@ instance Binary TyConBndrVis where
                   0 -> return AnonTCB
                   _ -> do { vis <- get bh; return (NamedTCB vis) } }
 
-
 {- *********************************************************************
 *                                                                      *
                The TyCon type
diff --git a/compiler/utils/Binary.hs b/compiler/utils/Binary.hs
index 447317ca47..a84624d24c 100644
--- a/compiler/utils/Binary.hs
+++ b/compiler/utils/Binary.hs
@@ -63,12 +63,16 @@ module Binary
 import GhcPrelude
 
 import {-# SOURCE #-} Name (Name)
+import Bag
 import FastString
 import Panic
+import Unique
 import UniqFM
+import UniqSet
 import FastMutInt
 import Fingerprint
 import BasicTypes
+import {-# SOURCE #-} PrimOp
 import SrcLoc
 
 import Foreign
@@ -76,14 +80,17 @@ import Data.Array
 import Data.ByteString (ByteString)
 import qualified Data.ByteString.Internal as BS
 import qualified Data.ByteString.Unsafe   as BS
+import qualified Data.IntMap              as IM
 import Data.IORef
 import Data.Char                ( ord, chr )
+import Data.List                ( find )
 import Data.Time
 import Type.Reflection
 import Type.Reflection.Unsafe
 import Data.Kind (Type)
 import GHC.Exts (TYPE, RuntimeRep(..), VecCount(..), VecElem(..))
-import Control.Monad            ( when )
+import Data.Typeable            ( )
+import Control.Monad            ( when, replicateM )
 import System.IO as IO
 import System.IO.Unsafe         ( unsafeInterleaveIO )
 import System.IO.Error          ( mkIOError, eofErrorType )
@@ -380,8 +387,8 @@ instance Binary () where
     get  _    = return ()
 
 instance Binary Bool where
-    put_ bh b = putByte bh (fromIntegral (fromEnum b))
-    get  bh   = do x <- getWord8 bh; return $! (toEnum (fromIntegral x))
+    put_ bh b = putByte bh (if b then 1 else 0)
+    get  bh   = do x <- getByte bh; return $! if x == 0 then False else True
 
 instance Binary Char where
     put_  bh c = put_ bh (fromIntegral (ord c) :: Word32)
@@ -1173,3 +1180,121 @@ instance Binary SourceText where
         s <- get bh
         return (SourceText s)
       _ -> panic $ "Binary SourceText:" ++ show h
+
+instance Binary IntegralLit where
+  put_ bh (IL a b c) = put_ bh a >> put_ bh b >> put_ bh c
+  get bh = IL <$> get bh <*> get bh <*> get bh
+
+instance Binary FractionalLit where
+  put_ bh (FL a b c) = put_ bh a >> put_ bh b >> put_ bh c
+  get bh = FL <$> get bh <*> get bh <*> get bh
+
+instance Binary Boxity where
+  put_ bh b = case b of
+    Boxed   -> putByte bh 0
+    Unboxed -> putByte bh 1
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure Boxed
+      _ -> pure Unboxed
+
+instance Binary Unique where
+  put_ bh u = put_ bh (getKey u)
+  get bh = mkUniqueGrimily <$> get bh
+
+instance Binary ty => Binary (DefMethSpec ty) where
+  put_ bh s
+    = case s of
+        VanillaDM   -> putByte bh 0
+        GenericDM t -> putByte bh 1 >> put_ bh t
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure VanillaDM
+      _ -> GenericDM <$> get bh
+
+instance Binary a => Binary (IM.IntMap a) where
+  put_ bh m = put_ bh (IM.toAscList m)
+  get bh = IM.fromAscList <$> get bh
+
+instance Binary PrimOp where
+  put_ bh primop = put_ bh (primOpTag primop)
+  -- FIXME: inefficient.
+  get bh = do
+    tag <- getTag
+    case find (\p -> primOpTag p == tag) allThePrimOps of
+      Nothing -> error "Binary PrimOp.get: unknown primop tag"
+      Just p  -> pure p
+
+    where getTag :: IO Int
+          getTag = get bh
+
+instance Binary OccInfo where
+  put_ bh i
+    = case i of
+        ManyOccs a          -> putByte bh 0 >> put_ bh a
+        IAmDead             -> putByte bh 1
+        OneOcc a b c d      -> putByte bh 2 >> put_ bh a >> put_ bh b
+                                            >> put_ bh c >> put_ bh d
+        IAmALoopBreaker a b -> putByte bh 3 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ManyOccs <$> get bh
+      1 -> pure IAmDead
+      2 -> OneOcc <$> get bh <*> get bh <*> get bh <*> get bh
+      _ -> IAmALoopBreaker <$> get bh <*> get bh
+
+instance Binary TailCallInfo where
+  put_ bh i
+    = case i of
+        AlwaysTailCalled a -> putByte bh 0 >> put_ bh a
+        NoTailCallInfo     -> putByte bh 1
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> AlwaysTailCalled <$> get bh
+      _ -> pure NoTailCallInfo
+
+instance Binary OneShotInfo where
+  put_ bh i
+    = case i of
+        NoOneShotInfo -> putByte bh 0
+        OneShotLam    -> putByte bh 1
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure NoOneShotInfo
+      _ -> pure OneShotLam
+
+instance Binary LexicalFixity where
+  put_ bh f = case f of
+    Prefix -> putByte bh 0
+    Infix  -> putByte bh 1
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure Prefix
+      _ -> pure Infix
+
+instance Binary ele => Binary (UniqFM ele) where
+  put_ bh ufm = put_ bh (ufmToIntMap ufm)
+  get bh = intMapToUFM <$> get bh
+
+instance Binary a => Binary (UniqSet a) where
+  put_ bh s = put_ bh (getUniqSet s)
+  get bh = unsafeUFMToUniqSet <$> get bh
+
+instance Binary a => Binary (Bag a) where
+  put_ bh b = put_ bh (bagToList b)
+  get bh = listToBag <$> get bh
+
+instance Binary Origin where
+  put_ bh o = putByte bh $ case o of
+    FromSource -> 0
+    Generated  -> 1
+  get bh = getByte bh >>= \n -> case n of
+    0 -> pure FromSource
+    1 -> pure Generated
+    _ -> panic "Binary Origin.get: unknown tag"
diff --git a/compiler/utils/UniqDFM.hs b/compiler/utils/UniqDFM.hs
index 715600ddb8..90389da0d1 100644
--- a/compiler/utils/UniqDFM.hs
+++ b/compiler/utils/UniqDFM.hs
@@ -62,6 +62,7 @@ module UniqDFM (
 import GhcPrelude
 
 import Unique           ( Uniquable(..), Unique, getKey )
+import Binary
 import Outputable
 
 import qualified Data.IntMap as M
@@ -128,6 +129,10 @@ instance Eq val => Eq (TaggedVal val) where
 instance Functor TaggedVal where
   fmap f (TaggedVal val i) = TaggedVal (f val) i
 
+instance Binary val => Binary (TaggedVal val) where
+  put_ bh (TaggedVal a b) = put_ bh a >> put_ bh b
+  get bh = TaggedVal <$> get bh <*> get bh
+
 -- | Type of unique deterministic finite maps
 data UniqDFM ele =
   UDFM
@@ -139,6 +144,10 @@ data UniqDFM ele =
                                 -- time. See Note [Overflow on plusUDFM]
   deriving (Data, Functor)
 
+instance Binary ele => Binary (UniqDFM ele) where
+  put_ bh (UDFM a b) = put_ bh a >> put_ bh b
+  get bh = UDFM <$> get bh <*> get bh
+
 emptyUDFM :: UniqDFM elt
 emptyUDFM = UDFM M.empty 0
 
diff --git a/compiler/utils/UniqFM.hs b/compiler/utils/UniqFM.hs
index a80880f4e5..7a7c40ecfc 100644
--- a/compiler/utils/UniqFM.hs
+++ b/compiler/utils/UniqFM.hs
@@ -66,7 +66,7 @@ module UniqFM (
         lookupWithDefaultUFM, lookupWithDefaultUFM_Directly,
         nonDetEltsUFM, eltsUFM, nonDetKeysUFM,
         ufmToSet_Directly,
-        nonDetUFMToList, ufmToIntMap,
+        nonDetUFMToList, ufmToIntMap, intMapToUFM,
         pprUniqFM, pprUFM, pprUFMWithKeys, pluralUFM
     ) where
 
@@ -338,7 +338,10 @@ nonDetUFMToList (UFM m) = map (\(k, v) -> (getUnique k, v)) $ M.toList m
 ufmToIntMap :: UniqFM elt -> M.IntMap elt
 ufmToIntMap (UFM m) = m
 
--- Determines whether two 'UniqFm's contain the same keys.
+intMapToUFM :: M.IntMap elt -> UniqFM elt
+intMapToUFM = UFM
+
+-- Determines whether two 'UniqFM's contain the same keys.
 equalKeysUFM :: UniqFM a -> UniqFM b -> Bool
 equalKeysUFM (UFM m1) (UFM m2) = liftEq (\_ _ -> True) m1 m2
 
